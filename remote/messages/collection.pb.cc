// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collection.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "collection.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* CollectionRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollectionRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* CollectionRequest_GetGenreList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollectionRequest_GetGenreList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CollectionRequest_GetArtistList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollectionRequest_GetArtistList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CollectionRequest_GetReleaseList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollectionRequest_GetReleaseList_reflection_ = NULL;
const ::google::protobuf::Descriptor* CollectionRequest_GetTrackList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollectionRequest_GetTrackList_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CollectionRequest_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CollectionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CollectionResponse_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CollectionResponse_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* GenreList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GenreList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ArtistList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ArtistList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReleaseList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReleaseList_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrackList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrackList_reflection_ = NULL;
const ::google::protobuf::Descriptor* Genre_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Genre_reflection_ = NULL;
const ::google::protobuf::Descriptor* CoverArt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CoverArt_reflection_ = NULL;
const ::google::protobuf::Descriptor* Artist_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Artist_reflection_ = NULL;
const ::google::protobuf::Descriptor* Release_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Release_reflection_ = NULL;
const ::google::protobuf::Descriptor* Track_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Track_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_collection_2eproto() {
  protobuf_AddDesc_collection_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "collection.proto");
  GOOGLE_CHECK(file != NULL);
  CollectionRequest_descriptor_ = file->message_type(0);
  static const int CollectionRequest_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest, get_genres_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest, get_artists_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest, get_releases_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest, get_tracks_),
  };
  CollectionRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollectionRequest_descriptor_,
      CollectionRequest::default_instance_,
      CollectionRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollectionRequest));
  CollectionRequest_GetGenreList_descriptor_ = CollectionRequest_descriptor_->nested_type(0);
  static const int CollectionRequest_GetGenreList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetGenreList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetGenreList, preferred_batch_size_),
  };
  CollectionRequest_GetGenreList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollectionRequest_GetGenreList_descriptor_,
      CollectionRequest_GetGenreList::default_instance_,
      CollectionRequest_GetGenreList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetGenreList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetGenreList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollectionRequest_GetGenreList));
  CollectionRequest_GetArtistList_descriptor_ = CollectionRequest_descriptor_->nested_type(1);
  static const int CollectionRequest_GetArtistList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetArtistList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetArtistList, filter_genre_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetArtistList, preferred_batch_size_),
  };
  CollectionRequest_GetArtistList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollectionRequest_GetArtistList_descriptor_,
      CollectionRequest_GetArtistList::default_instance_,
      CollectionRequest_GetArtistList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetArtistList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetArtistList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollectionRequest_GetArtistList));
  CollectionRequest_GetReleaseList_descriptor_ = CollectionRequest_descriptor_->nested_type(2);
  static const int CollectionRequest_GetReleaseList_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetReleaseList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetReleaseList, artist_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetReleaseList, filter_genre_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetReleaseList, get_cover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetReleaseList, preferred_batch_size_),
  };
  CollectionRequest_GetReleaseList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollectionRequest_GetReleaseList_descriptor_,
      CollectionRequest_GetReleaseList::default_instance_,
      CollectionRequest_GetReleaseList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetReleaseList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetReleaseList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollectionRequest_GetReleaseList));
  CollectionRequest_GetTrackList_descriptor_ = CollectionRequest_descriptor_->nested_type(3);
  static const int CollectionRequest_GetTrackList_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, release_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, artist_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, filter_genre_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, disc_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, track_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, get_cover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, preferred_batch_size_),
  };
  CollectionRequest_GetTrackList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollectionRequest_GetTrackList_descriptor_,
      CollectionRequest_GetTrackList::default_instance_,
      CollectionRequest_GetTrackList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionRequest_GetTrackList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollectionRequest_GetTrackList));
  CollectionRequest_Type_descriptor_ = CollectionRequest_descriptor_->enum_type(0);
  CollectionResponse_descriptor_ = file->message_type(1);
  static const int CollectionResponse_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, genre_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, artist_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, release_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, track_list_),
  };
  CollectionResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CollectionResponse_descriptor_,
      CollectionResponse::default_instance_,
      CollectionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CollectionResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CollectionResponse));
  CollectionResponse_Type_descriptor_ = CollectionResponse_descriptor_->enum_type(0);
  GenreList_descriptor_ = file->message_type(2);
  static const int GenreList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenreList, last_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenreList, genres_),
  };
  GenreList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GenreList_descriptor_,
      GenreList::default_instance_,
      GenreList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenreList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GenreList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GenreList));
  ArtistList_descriptor_ = file->message_type(3);
  static const int ArtistList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArtistList, last_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArtistList, artists_),
  };
  ArtistList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ArtistList_descriptor_,
      ArtistList::default_instance_,
      ArtistList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArtistList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ArtistList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ArtistList));
  ReleaseList_descriptor_ = file->message_type(4);
  static const int ReleaseList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReleaseList, last_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReleaseList, releases_),
  };
  ReleaseList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReleaseList_descriptor_,
      ReleaseList::default_instance_,
      ReleaseList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReleaseList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReleaseList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReleaseList));
  TrackList_descriptor_ = file->message_type(5);
  static const int TrackList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackList, last_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackList, tracks_),
  };
  TrackList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TrackList_descriptor_,
      TrackList::default_instance_,
      TrackList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrackList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TrackList));
  Genre_descriptor_ = file->message_type(6);
  static const int Genre_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Genre, name_),
  };
  Genre_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Genre_descriptor_,
      Genre::default_instance_,
      Genre_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Genre, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Genre, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Genre));
  CoverArt_descriptor_ = file->message_type(7);
  static const int CoverArt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoverArt, mime_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoverArt, data_),
  };
  CoverArt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CoverArt_descriptor_,
      CoverArt::default_instance_,
      CoverArt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoverArt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoverArt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CoverArt));
  Artist_descriptor_ = file->message_type(8);
  static const int Artist_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Artist, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Artist, nb_releases_),
  };
  Artist_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Artist_descriptor_,
      Artist::default_instance_,
      Artist_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Artist, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Artist, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Artist));
  Release_descriptor_ = file->message_type(9);
  static const int Release_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Release, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Release, nb_tracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Release, duration_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Release, coverart_),
  };
  Release_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Release_descriptor_,
      Release::default_instance_,
      Release_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Release, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Release, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Release));
  Track_descriptor_ = file->message_type(10);
  static const int Track_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, media_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, disc_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, track_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, artist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, release_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, duration_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, release_date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, original_release_date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, genres_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, coverart_),
  };
  Track_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Track_descriptor_,
      Track::default_instance_,
      Track_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Track));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_collection_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollectionRequest_descriptor_, &CollectionRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollectionRequest_GetGenreList_descriptor_, &CollectionRequest_GetGenreList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollectionRequest_GetArtistList_descriptor_, &CollectionRequest_GetArtistList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollectionRequest_GetReleaseList_descriptor_, &CollectionRequest_GetReleaseList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollectionRequest_GetTrackList_descriptor_, &CollectionRequest_GetTrackList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CollectionResponse_descriptor_, &CollectionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GenreList_descriptor_, &GenreList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ArtistList_descriptor_, &ArtistList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReleaseList_descriptor_, &ReleaseList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TrackList_descriptor_, &TrackList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Genre_descriptor_, &Genre::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CoverArt_descriptor_, &CoverArt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Artist_descriptor_, &Artist::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Release_descriptor_, &Release::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Track_descriptor_, &Track::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_collection_2eproto() {
  delete CollectionRequest::default_instance_;
  delete CollectionRequest_reflection_;
  delete CollectionRequest_GetGenreList::default_instance_;
  delete CollectionRequest_GetGenreList_reflection_;
  delete CollectionRequest_GetArtistList::default_instance_;
  delete CollectionRequest_GetArtistList_reflection_;
  delete CollectionRequest_GetReleaseList::default_instance_;
  delete CollectionRequest_GetReleaseList_reflection_;
  delete CollectionRequest_GetTrackList::default_instance_;
  delete CollectionRequest_GetTrackList_reflection_;
  delete CollectionResponse::default_instance_;
  delete CollectionResponse_reflection_;
  delete GenreList::default_instance_;
  delete GenreList_reflection_;
  delete ArtistList::default_instance_;
  delete ArtistList_reflection_;
  delete ReleaseList::default_instance_;
  delete ReleaseList_reflection_;
  delete TrackList::default_instance_;
  delete TrackList_reflection_;
  delete Genre::default_instance_;
  delete Genre_reflection_;
  delete CoverArt::default_instance_;
  delete CoverArt_reflection_;
  delete Artist::default_instance_;
  delete Artist_reflection_;
  delete Release::default_instance_;
  delete Release_reflection_;
  delete Track::default_instance_;
  delete Track_reflection_;
}

void protobuf_AddDesc_collection_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_common_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020collection.proto\032\014common.proto\"\305\006\n\021Col"
    "lectionRequest\022%\n\004type\030\001 \002(\0162\027.Collectio"
    "nRequest.Type\0223\n\nget_genres\030\002 \001(\0132\037.Coll"
    "ectionRequest.GetGenreList\0225\n\013get_artist"
    "s\030\003 \001(\0132 .CollectionRequest.GetArtistLis"
    "t\0227\n\014get_releases\030\004 \001(\0132!.CollectionRequ"
    "est.GetReleaseList\0223\n\nget_tracks\030\005 \001(\0132\037"
    ".CollectionRequest.GetTrackList\032A\n\014GetGe"
    "nreList\022\023\n\013filter_name\030\001 \001(\t\022\034\n\024preferre"
    "d_batch_size\030\002 \001(\r\032X\n\rGetArtistList\022\023\n\013f"
    "ilter_name\030\001 \001(\t\022\024\n\014filter_genre\030\002 \003(\t\022\034"
    "\n\024preferred_batch_size\030\003 \001(\r\032\201\001\n\016GetRele"
    "aseList\022\023\n\013filter_name\030\001 \001(\t\022\023\n\013artist_n"
    "ame\030\002 \003(\t\022\024\n\014filter_genre\030\003 \003(\t\022\021\n\tget_c"
    "over\030\004 \001(\010\022\034\n\024preferred_batch_size\030\005 \001(\r"
    "\032\300\001\n\014GetTrackList\022\023\n\013filter_name\030\001 \001(\t\022\024"
    "\n\014release_name\030\002 \003(\t\022\023\n\013artist_name\030\003 \003("
    "\t\022\024\n\014filter_genre\030\004 \003(\t\022\023\n\013disc_number\030\005"
    " \001(\r\022\024\n\014track_number\030\006 \001(\r\022\021\n\tget_cover\030"
    "\007 \001(\010\022\034\n\024preferred_batch_size\030\010 \001(\r\"K\n\004T"
    "ype\022\025\n\021TypeGetArtistList\020\000\022\026\n\022TypeGetRel"
    "easeList\020\001\022\024\n\020TypeGetTrackList\020\002\"\260\002\n\022Col"
    "lectionResponse\022\025\n\005error\030\001 \002(\0132\006.Error\022&"
    "\n\004type\030\002 \001(\0162\030.CollectionResponse.Type\022\036"
    "\n\ngenre_list\030\003 \001(\0132\n.GenreList\022 \n\013artist"
    "_list\030\004 \001(\0132\013.ArtistList\022\"\n\014release_list"
    "\030\005 \001(\0132\014.ReleaseList\022\036\n\ntrack_list\030\006 \001(\013"
    "2\n.TrackList\"U\n\004Type\022\021\n\rTypeGenreList\020\001\022"
    "\022\n\016TypeArtistList\020\002\022\023\n\017TypeReleaseList\020\003"
    "\022\021\n\rTypeTrackList\020\004\"1\n\tGenreList\022\014\n\004last"
    "\030\001 \002(\010\022\026\n\006genres\030\002 \003(\0132\006.Genre\"4\n\nArtist"
    "List\022\014\n\004last\030\001 \002(\010\022\030\n\007artists\030\002 \003(\0132\007.Ar"
    "tist\"7\n\013ReleaseList\022\014\n\004last\030\001 \002(\010\022\032\n\010rel"
    "eases\030\002 \003(\0132\010.Release\"1\n\tTrackList\022\014\n\004la"
    "st\030\001 \002(\010\022\026\n\006tracks\030\002 \003(\0132\006.Track\"\025\n\005Genr"
    "e\022\014\n\004name\030\001 \002(\t\"+\n\010CoverArt\022\021\n\tmime_type"
    "\030\001 \001(\t\022\014\n\004data\030\002 \003(\014\"+\n\006Artist\022\014\n\004name\030\001"
    " \002(\t\022\023\n\013nb_releases\030\002 \002(\r\"^\n\007Release\022\014\n\004"
    "name\030\001 \002(\t\022\021\n\tnb_tracks\030\002 \002(\r\022\025\n\rduratio"
    "n_secs\030\003 \002(\r\022\033\n\010coverArt\030\004 \001(\0132\t.CoverAr"
    "t\"\341\001\n\005Track\022\020\n\010media_id\030\001 \002(\003\022\023\n\013disc_nu"
    "mber\030\002 \001(\r\022\024\n\014track_number\030\003 \001(\r\022\016\n\006arti"
    "st\030\004 \001(\t\022\017\n\007release\030\005 \001(\t\022\014\n\004name\030\006 \002(\t\022"
    "\025\n\rduration_secs\030\007 \002(\r\022\024\n\014release_date\030\010"
    " \001(\t\022\035\n\025original_release_date\030\t \001(\t\022\016\n\006g"
    "enres\030\n \003(\t\022\020\n\010coverArt\030\013 \001(\014", 1829);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "collection.proto", &protobuf_RegisterTypes);
  CollectionRequest::default_instance_ = new CollectionRequest();
  CollectionRequest_GetGenreList::default_instance_ = new CollectionRequest_GetGenreList();
  CollectionRequest_GetArtistList::default_instance_ = new CollectionRequest_GetArtistList();
  CollectionRequest_GetReleaseList::default_instance_ = new CollectionRequest_GetReleaseList();
  CollectionRequest_GetTrackList::default_instance_ = new CollectionRequest_GetTrackList();
  CollectionResponse::default_instance_ = new CollectionResponse();
  GenreList::default_instance_ = new GenreList();
  ArtistList::default_instance_ = new ArtistList();
  ReleaseList::default_instance_ = new ReleaseList();
  TrackList::default_instance_ = new TrackList();
  Genre::default_instance_ = new Genre();
  CoverArt::default_instance_ = new CoverArt();
  Artist::default_instance_ = new Artist();
  Release::default_instance_ = new Release();
  Track::default_instance_ = new Track();
  CollectionRequest::default_instance_->InitAsDefaultInstance();
  CollectionRequest_GetGenreList::default_instance_->InitAsDefaultInstance();
  CollectionRequest_GetArtistList::default_instance_->InitAsDefaultInstance();
  CollectionRequest_GetReleaseList::default_instance_->InitAsDefaultInstance();
  CollectionRequest_GetTrackList::default_instance_->InitAsDefaultInstance();
  CollectionResponse::default_instance_->InitAsDefaultInstance();
  GenreList::default_instance_->InitAsDefaultInstance();
  ArtistList::default_instance_->InitAsDefaultInstance();
  ReleaseList::default_instance_->InitAsDefaultInstance();
  TrackList::default_instance_->InitAsDefaultInstance();
  Genre::default_instance_->InitAsDefaultInstance();
  CoverArt::default_instance_->InitAsDefaultInstance();
  Artist::default_instance_->InitAsDefaultInstance();
  Release::default_instance_->InitAsDefaultInstance();
  Track::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_collection_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_collection_2eproto {
  StaticDescriptorInitializer_collection_2eproto() {
    protobuf_AddDesc_collection_2eproto();
  }
} static_descriptor_initializer_collection_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* CollectionRequest_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionRequest_Type_descriptor_;
}
bool CollectionRequest_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CollectionRequest_Type CollectionRequest::TypeGetArtistList;
const CollectionRequest_Type CollectionRequest::TypeGetReleaseList;
const CollectionRequest_Type CollectionRequest::TypeGetTrackList;
const CollectionRequest_Type CollectionRequest::Type_MIN;
const CollectionRequest_Type CollectionRequest::Type_MAX;
const int CollectionRequest::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CollectionRequest_GetGenreList::kFilterNameFieldNumber;
const int CollectionRequest_GetGenreList::kPreferredBatchSizeFieldNumber;
#endif  // !_MSC_VER

CollectionRequest_GetGenreList::CollectionRequest_GetGenreList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollectionRequest_GetGenreList::InitAsDefaultInstance() {
}

CollectionRequest_GetGenreList::CollectionRequest_GetGenreList(const CollectionRequest_GetGenreList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollectionRequest_GetGenreList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  preferred_batch_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectionRequest_GetGenreList::~CollectionRequest_GetGenreList() {
  SharedDtor();
}

void CollectionRequest_GetGenreList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
  }
}

void CollectionRequest_GetGenreList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollectionRequest_GetGenreList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionRequest_GetGenreList_descriptor_;
}

const CollectionRequest_GetGenreList& CollectionRequest_GetGenreList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

CollectionRequest_GetGenreList* CollectionRequest_GetGenreList::default_instance_ = NULL;

CollectionRequest_GetGenreList* CollectionRequest_GetGenreList::New() const {
  return new CollectionRequest_GetGenreList;
}

void CollectionRequest_GetGenreList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    preferred_batch_size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollectionRequest_GetGenreList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_preferred_batch_size;
        break;
      }

      // optional uint32 preferred_batch_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_preferred_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &preferred_batch_size_)));
          set_has_preferred_batch_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectionRequest_GetGenreList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // optional uint32 preferred_batch_size = 2;
  if (has_preferred_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->preferred_batch_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollectionRequest_GetGenreList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // optional uint32 preferred_batch_size = 2;
  if (has_preferred_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->preferred_batch_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollectionRequest_GetGenreList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // optional uint32 preferred_batch_size = 2;
    if (has_preferred_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->preferred_batch_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectionRequest_GetGenreList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollectionRequest_GetGenreList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollectionRequest_GetGenreList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollectionRequest_GetGenreList::MergeFrom(const CollectionRequest_GetGenreList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_preferred_batch_size()) {
      set_preferred_batch_size(from.preferred_batch_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollectionRequest_GetGenreList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollectionRequest_GetGenreList::CopyFrom(const CollectionRequest_GetGenreList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectionRequest_GetGenreList::IsInitialized() const {

  return true;
}

void CollectionRequest_GetGenreList::Swap(CollectionRequest_GetGenreList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    std::swap(preferred_batch_size_, other->preferred_batch_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollectionRequest_GetGenreList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollectionRequest_GetGenreList_descriptor_;
  metadata.reflection = CollectionRequest_GetGenreList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CollectionRequest_GetArtistList::kFilterNameFieldNumber;
const int CollectionRequest_GetArtistList::kFilterGenreFieldNumber;
const int CollectionRequest_GetArtistList::kPreferredBatchSizeFieldNumber;
#endif  // !_MSC_VER

CollectionRequest_GetArtistList::CollectionRequest_GetArtistList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollectionRequest_GetArtistList::InitAsDefaultInstance() {
}

CollectionRequest_GetArtistList::CollectionRequest_GetArtistList(const CollectionRequest_GetArtistList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollectionRequest_GetArtistList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  preferred_batch_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectionRequest_GetArtistList::~CollectionRequest_GetArtistList() {
  SharedDtor();
}

void CollectionRequest_GetArtistList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
  }
}

void CollectionRequest_GetArtistList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollectionRequest_GetArtistList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionRequest_GetArtistList_descriptor_;
}

const CollectionRequest_GetArtistList& CollectionRequest_GetArtistList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

CollectionRequest_GetArtistList* CollectionRequest_GetArtistList::default_instance_ = NULL;

CollectionRequest_GetArtistList* CollectionRequest_GetArtistList::New() const {
  return new CollectionRequest_GetArtistList;
}

void CollectionRequest_GetArtistList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    preferred_batch_size_ = 0u;
  }
  filter_genre_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollectionRequest_GetArtistList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filter_genre;
        break;
      }

      // repeated string filter_genre = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_genre:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_genre()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_genre(this->filter_genre_size() - 1).data(),
            this->filter_genre(this->filter_genre_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filter_genre;
        if (input->ExpectTag(24)) goto parse_preferred_batch_size;
        break;
      }

      // optional uint32 preferred_batch_size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_preferred_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &preferred_batch_size_)));
          set_has_preferred_batch_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectionRequest_GetArtistList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // repeated string filter_genre = 2;
  for (int i = 0; i < this->filter_genre_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->filter_genre(i).data(), this->filter_genre(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->filter_genre(i), output);
  }

  // optional uint32 preferred_batch_size = 3;
  if (has_preferred_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->preferred_batch_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollectionRequest_GetArtistList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // repeated string filter_genre = 2;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_genre(i).data(), this->filter_genre(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->filter_genre(i), target);
  }

  // optional uint32 preferred_batch_size = 3;
  if (has_preferred_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->preferred_batch_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollectionRequest_GetArtistList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // optional uint32 preferred_batch_size = 3;
    if (has_preferred_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->preferred_batch_size());
    }

  }
  // repeated string filter_genre = 2;
  total_size += 1 * this->filter_genre_size();
  for (int i = 0; i < this->filter_genre_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_genre(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectionRequest_GetArtistList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollectionRequest_GetArtistList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollectionRequest_GetArtistList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollectionRequest_GetArtistList::MergeFrom(const CollectionRequest_GetArtistList& from) {
  GOOGLE_CHECK_NE(&from, this);
  filter_genre_.MergeFrom(from.filter_genre_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_preferred_batch_size()) {
      set_preferred_batch_size(from.preferred_batch_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollectionRequest_GetArtistList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollectionRequest_GetArtistList::CopyFrom(const CollectionRequest_GetArtistList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectionRequest_GetArtistList::IsInitialized() const {

  return true;
}

void CollectionRequest_GetArtistList::Swap(CollectionRequest_GetArtistList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    filter_genre_.Swap(&other->filter_genre_);
    std::swap(preferred_batch_size_, other->preferred_batch_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollectionRequest_GetArtistList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollectionRequest_GetArtistList_descriptor_;
  metadata.reflection = CollectionRequest_GetArtistList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CollectionRequest_GetReleaseList::kFilterNameFieldNumber;
const int CollectionRequest_GetReleaseList::kArtistNameFieldNumber;
const int CollectionRequest_GetReleaseList::kFilterGenreFieldNumber;
const int CollectionRequest_GetReleaseList::kGetCoverFieldNumber;
const int CollectionRequest_GetReleaseList::kPreferredBatchSizeFieldNumber;
#endif  // !_MSC_VER

CollectionRequest_GetReleaseList::CollectionRequest_GetReleaseList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollectionRequest_GetReleaseList::InitAsDefaultInstance() {
}

CollectionRequest_GetReleaseList::CollectionRequest_GetReleaseList(const CollectionRequest_GetReleaseList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollectionRequest_GetReleaseList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  get_cover_ = false;
  preferred_batch_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectionRequest_GetReleaseList::~CollectionRequest_GetReleaseList() {
  SharedDtor();
}

void CollectionRequest_GetReleaseList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
  }
}

void CollectionRequest_GetReleaseList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollectionRequest_GetReleaseList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionRequest_GetReleaseList_descriptor_;
}

const CollectionRequest_GetReleaseList& CollectionRequest_GetReleaseList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

CollectionRequest_GetReleaseList* CollectionRequest_GetReleaseList::default_instance_ = NULL;

CollectionRequest_GetReleaseList* CollectionRequest_GetReleaseList::New() const {
  return new CollectionRequest_GetReleaseList;
}

void CollectionRequest_GetReleaseList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    get_cover_ = false;
    preferred_batch_size_ = 0u;
  }
  artist_name_.Clear();
  filter_genre_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollectionRequest_GetReleaseList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artist_name;
        break;
      }

      // repeated string artist_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_artist_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist_name(this->artist_name_size() - 1).data(),
            this->artist_name(this->artist_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artist_name;
        if (input->ExpectTag(26)) goto parse_filter_genre;
        break;
      }

      // repeated string filter_genre = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_genre:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_genre()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_genre(this->filter_genre_size() - 1).data(),
            this->filter_genre(this->filter_genre_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_filter_genre;
        if (input->ExpectTag(32)) goto parse_get_cover;
        break;
      }

      // optional bool get_cover = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_get_cover:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &get_cover_)));
          set_has_get_cover();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_preferred_batch_size;
        break;
      }

      // optional uint32 preferred_batch_size = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_preferred_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &preferred_batch_size_)));
          set_has_preferred_batch_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectionRequest_GetReleaseList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // repeated string artist_name = 2;
  for (int i = 0; i < this->artist_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->artist_name(i).data(), this->artist_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->artist_name(i), output);
  }

  // repeated string filter_genre = 3;
  for (int i = 0; i < this->filter_genre_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->filter_genre(i).data(), this->filter_genre(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->filter_genre(i), output);
  }

  // optional bool get_cover = 4;
  if (has_get_cover()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->get_cover(), output);
  }

  // optional uint32 preferred_batch_size = 5;
  if (has_preferred_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->preferred_batch_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollectionRequest_GetReleaseList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // repeated string artist_name = 2;
  for (int i = 0; i < this->artist_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist_name(i).data(), this->artist_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->artist_name(i), target);
  }

  // repeated string filter_genre = 3;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_genre(i).data(), this->filter_genre(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->filter_genre(i), target);
  }

  // optional bool get_cover = 4;
  if (has_get_cover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->get_cover(), target);
  }

  // optional uint32 preferred_batch_size = 5;
  if (has_preferred_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->preferred_batch_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollectionRequest_GetReleaseList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // optional bool get_cover = 4;
    if (has_get_cover()) {
      total_size += 1 + 1;
    }

    // optional uint32 preferred_batch_size = 5;
    if (has_preferred_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->preferred_batch_size());
    }

  }
  // repeated string artist_name = 2;
  total_size += 1 * this->artist_name_size();
  for (int i = 0; i < this->artist_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->artist_name(i));
  }

  // repeated string filter_genre = 3;
  total_size += 1 * this->filter_genre_size();
  for (int i = 0; i < this->filter_genre_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_genre(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectionRequest_GetReleaseList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollectionRequest_GetReleaseList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollectionRequest_GetReleaseList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollectionRequest_GetReleaseList::MergeFrom(const CollectionRequest_GetReleaseList& from) {
  GOOGLE_CHECK_NE(&from, this);
  artist_name_.MergeFrom(from.artist_name_);
  filter_genre_.MergeFrom(from.filter_genre_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_get_cover()) {
      set_get_cover(from.get_cover());
    }
    if (from.has_preferred_batch_size()) {
      set_preferred_batch_size(from.preferred_batch_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollectionRequest_GetReleaseList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollectionRequest_GetReleaseList::CopyFrom(const CollectionRequest_GetReleaseList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectionRequest_GetReleaseList::IsInitialized() const {

  return true;
}

void CollectionRequest_GetReleaseList::Swap(CollectionRequest_GetReleaseList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    artist_name_.Swap(&other->artist_name_);
    filter_genre_.Swap(&other->filter_genre_);
    std::swap(get_cover_, other->get_cover_);
    std::swap(preferred_batch_size_, other->preferred_batch_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollectionRequest_GetReleaseList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollectionRequest_GetReleaseList_descriptor_;
  metadata.reflection = CollectionRequest_GetReleaseList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CollectionRequest_GetTrackList::kFilterNameFieldNumber;
const int CollectionRequest_GetTrackList::kReleaseNameFieldNumber;
const int CollectionRequest_GetTrackList::kArtistNameFieldNumber;
const int CollectionRequest_GetTrackList::kFilterGenreFieldNumber;
const int CollectionRequest_GetTrackList::kDiscNumberFieldNumber;
const int CollectionRequest_GetTrackList::kTrackNumberFieldNumber;
const int CollectionRequest_GetTrackList::kGetCoverFieldNumber;
const int CollectionRequest_GetTrackList::kPreferredBatchSizeFieldNumber;
#endif  // !_MSC_VER

CollectionRequest_GetTrackList::CollectionRequest_GetTrackList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollectionRequest_GetTrackList::InitAsDefaultInstance() {
}

CollectionRequest_GetTrackList::CollectionRequest_GetTrackList(const CollectionRequest_GetTrackList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollectionRequest_GetTrackList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  disc_number_ = 0u;
  track_number_ = 0u;
  get_cover_ = false;
  preferred_batch_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectionRequest_GetTrackList::~CollectionRequest_GetTrackList() {
  SharedDtor();
}

void CollectionRequest_GetTrackList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
  }
}

void CollectionRequest_GetTrackList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollectionRequest_GetTrackList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionRequest_GetTrackList_descriptor_;
}

const CollectionRequest_GetTrackList& CollectionRequest_GetTrackList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

CollectionRequest_GetTrackList* CollectionRequest_GetTrackList::default_instance_ = NULL;

CollectionRequest_GetTrackList* CollectionRequest_GetTrackList::New() const {
  return new CollectionRequest_GetTrackList;
}

void CollectionRequest_GetTrackList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    disc_number_ = 0u;
    track_number_ = 0u;
    get_cover_ = false;
    preferred_batch_size_ = 0u;
  }
  release_name_.Clear();
  artist_name_.Clear();
  filter_genre_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollectionRequest_GetTrackList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_release_name;
        break;
      }

      // repeated string release_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_release_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release_name(this->release_name_size() - 1).data(),
            this->release_name(this->release_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_release_name;
        if (input->ExpectTag(26)) goto parse_artist_name;
        break;
      }

      // repeated string artist_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_artist_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist_name(this->artist_name_size() - 1).data(),
            this->artist_name(this->artist_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_artist_name;
        if (input->ExpectTag(34)) goto parse_filter_genre;
        break;
      }

      // repeated string filter_genre = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_genre:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_genre()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_genre(this->filter_genre_size() - 1).data(),
            this->filter_genre(this->filter_genre_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_filter_genre;
        if (input->ExpectTag(40)) goto parse_disc_number;
        break;
      }

      // optional uint32 disc_number = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_disc_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &disc_number_)));
          set_has_disc_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_track_number;
        break;
      }

      // optional uint32 track_number = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_track_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &track_number_)));
          set_has_track_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_get_cover;
        break;
      }

      // optional bool get_cover = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_get_cover:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &get_cover_)));
          set_has_get_cover();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_preferred_batch_size;
        break;
      }

      // optional uint32 preferred_batch_size = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_preferred_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &preferred_batch_size_)));
          set_has_preferred_batch_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectionRequest_GetTrackList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // repeated string release_name = 2;
  for (int i = 0; i < this->release_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->release_name(i).data(), this->release_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->release_name(i), output);
  }

  // repeated string artist_name = 3;
  for (int i = 0; i < this->artist_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->artist_name(i).data(), this->artist_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->artist_name(i), output);
  }

  // repeated string filter_genre = 4;
  for (int i = 0; i < this->filter_genre_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->filter_genre(i).data(), this->filter_genre(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->filter_genre(i), output);
  }

  // optional uint32 disc_number = 5;
  if (has_disc_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->disc_number(), output);
  }

  // optional uint32 track_number = 6;
  if (has_track_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->track_number(), output);
  }

  // optional bool get_cover = 7;
  if (has_get_cover()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->get_cover(), output);
  }

  // optional uint32 preferred_batch_size = 8;
  if (has_preferred_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->preferred_batch_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollectionRequest_GetTrackList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // repeated string release_name = 2;
  for (int i = 0; i < this->release_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_name(i).data(), this->release_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->release_name(i), target);
  }

  // repeated string artist_name = 3;
  for (int i = 0; i < this->artist_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist_name(i).data(), this->artist_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->artist_name(i), target);
  }

  // repeated string filter_genre = 4;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_genre(i).data(), this->filter_genre(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(4, this->filter_genre(i), target);
  }

  // optional uint32 disc_number = 5;
  if (has_disc_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->disc_number(), target);
  }

  // optional uint32 track_number = 6;
  if (has_track_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->track_number(), target);
  }

  // optional bool get_cover = 7;
  if (has_get_cover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->get_cover(), target);
  }

  // optional uint32 preferred_batch_size = 8;
  if (has_preferred_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->preferred_batch_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollectionRequest_GetTrackList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // optional uint32 disc_number = 5;
    if (has_disc_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->disc_number());
    }

    // optional uint32 track_number = 6;
    if (has_track_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->track_number());
    }

    // optional bool get_cover = 7;
    if (has_get_cover()) {
      total_size += 1 + 1;
    }

    // optional uint32 preferred_batch_size = 8;
    if (has_preferred_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->preferred_batch_size());
    }

  }
  // repeated string release_name = 2;
  total_size += 1 * this->release_name_size();
  for (int i = 0; i < this->release_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->release_name(i));
  }

  // repeated string artist_name = 3;
  total_size += 1 * this->artist_name_size();
  for (int i = 0; i < this->artist_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->artist_name(i));
  }

  // repeated string filter_genre = 4;
  total_size += 1 * this->filter_genre_size();
  for (int i = 0; i < this->filter_genre_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_genre(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectionRequest_GetTrackList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollectionRequest_GetTrackList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollectionRequest_GetTrackList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollectionRequest_GetTrackList::MergeFrom(const CollectionRequest_GetTrackList& from) {
  GOOGLE_CHECK_NE(&from, this);
  release_name_.MergeFrom(from.release_name_);
  artist_name_.MergeFrom(from.artist_name_);
  filter_genre_.MergeFrom(from.filter_genre_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_disc_number()) {
      set_disc_number(from.disc_number());
    }
    if (from.has_track_number()) {
      set_track_number(from.track_number());
    }
    if (from.has_get_cover()) {
      set_get_cover(from.get_cover());
    }
    if (from.has_preferred_batch_size()) {
      set_preferred_batch_size(from.preferred_batch_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollectionRequest_GetTrackList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollectionRequest_GetTrackList::CopyFrom(const CollectionRequest_GetTrackList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectionRequest_GetTrackList::IsInitialized() const {

  return true;
}

void CollectionRequest_GetTrackList::Swap(CollectionRequest_GetTrackList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    release_name_.Swap(&other->release_name_);
    artist_name_.Swap(&other->artist_name_);
    filter_genre_.Swap(&other->filter_genre_);
    std::swap(disc_number_, other->disc_number_);
    std::swap(track_number_, other->track_number_);
    std::swap(get_cover_, other->get_cover_);
    std::swap(preferred_batch_size_, other->preferred_batch_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollectionRequest_GetTrackList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollectionRequest_GetTrackList_descriptor_;
  metadata.reflection = CollectionRequest_GetTrackList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int CollectionRequest::kTypeFieldNumber;
const int CollectionRequest::kGetGenresFieldNumber;
const int CollectionRequest::kGetArtistsFieldNumber;
const int CollectionRequest::kGetReleasesFieldNumber;
const int CollectionRequest::kGetTracksFieldNumber;
#endif  // !_MSC_VER

CollectionRequest::CollectionRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollectionRequest::InitAsDefaultInstance() {
  get_genres_ = const_cast< ::CollectionRequest_GetGenreList*>(&::CollectionRequest_GetGenreList::default_instance());
  get_artists_ = const_cast< ::CollectionRequest_GetArtistList*>(&::CollectionRequest_GetArtistList::default_instance());
  get_releases_ = const_cast< ::CollectionRequest_GetReleaseList*>(&::CollectionRequest_GetReleaseList::default_instance());
  get_tracks_ = const_cast< ::CollectionRequest_GetTrackList*>(&::CollectionRequest_GetTrackList::default_instance());
}

CollectionRequest::CollectionRequest(const CollectionRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollectionRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  get_genres_ = NULL;
  get_artists_ = NULL;
  get_releases_ = NULL;
  get_tracks_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectionRequest::~CollectionRequest() {
  SharedDtor();
}

void CollectionRequest::SharedDtor() {
  if (this != default_instance_) {
    delete get_genres_;
    delete get_artists_;
    delete get_releases_;
    delete get_tracks_;
  }
}

void CollectionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollectionRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionRequest_descriptor_;
}

const CollectionRequest& CollectionRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

CollectionRequest* CollectionRequest::default_instance_ = NULL;

CollectionRequest* CollectionRequest::New() const {
  return new CollectionRequest;
}

void CollectionRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_get_genres()) {
      if (get_genres_ != NULL) get_genres_->::CollectionRequest_GetGenreList::Clear();
    }
    if (has_get_artists()) {
      if (get_artists_ != NULL) get_artists_->::CollectionRequest_GetArtistList::Clear();
    }
    if (has_get_releases()) {
      if (get_releases_ != NULL) get_releases_->::CollectionRequest_GetReleaseList::Clear();
    }
    if (has_get_tracks()) {
      if (get_tracks_ != NULL) get_tracks_->::CollectionRequest_GetTrackList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollectionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .CollectionRequest.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CollectionRequest_Type_IsValid(value)) {
            set_type(static_cast< ::CollectionRequest_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_get_genres;
        break;
      }

      // optional .CollectionRequest.GetGenreList get_genres = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_genres()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_artists;
        break;
      }

      // optional .CollectionRequest.GetArtistList get_artists = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_artists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_artists()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_get_releases;
        break;
      }

      // optional .CollectionRequest.GetReleaseList get_releases = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_releases:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_releases()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_get_tracks;
        break;
      }

      // optional .CollectionRequest.GetTrackList get_tracks = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_tracks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_tracks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .CollectionRequest.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .CollectionRequest.GetGenreList get_genres = 2;
  if (has_get_genres()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->get_genres(), output);
  }

  // optional .CollectionRequest.GetArtistList get_artists = 3;
  if (has_get_artists()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_artists(), output);
  }

  // optional .CollectionRequest.GetReleaseList get_releases = 4;
  if (has_get_releases()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->get_releases(), output);
  }

  // optional .CollectionRequest.GetTrackList get_tracks = 5;
  if (has_get_tracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->get_tracks(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollectionRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .CollectionRequest.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .CollectionRequest.GetGenreList get_genres = 2;
  if (has_get_genres()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->get_genres(), target);
  }

  // optional .CollectionRequest.GetArtistList get_artists = 3;
  if (has_get_artists()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_artists(), target);
  }

  // optional .CollectionRequest.GetReleaseList get_releases = 4;
  if (has_get_releases()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->get_releases(), target);
  }

  // optional .CollectionRequest.GetTrackList get_tracks = 5;
  if (has_get_tracks()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->get_tracks(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollectionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .CollectionRequest.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .CollectionRequest.GetGenreList get_genres = 2;
    if (has_get_genres()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_genres());
    }

    // optional .CollectionRequest.GetArtistList get_artists = 3;
    if (has_get_artists()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_artists());
    }

    // optional .CollectionRequest.GetReleaseList get_releases = 4;
    if (has_get_releases()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_releases());
    }

    // optional .CollectionRequest.GetTrackList get_tracks = 5;
    if (has_get_tracks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_tracks());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectionRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollectionRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollectionRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollectionRequest::MergeFrom(const CollectionRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_get_genres()) {
      mutable_get_genres()->::CollectionRequest_GetGenreList::MergeFrom(from.get_genres());
    }
    if (from.has_get_artists()) {
      mutable_get_artists()->::CollectionRequest_GetArtistList::MergeFrom(from.get_artists());
    }
    if (from.has_get_releases()) {
      mutable_get_releases()->::CollectionRequest_GetReleaseList::MergeFrom(from.get_releases());
    }
    if (from.has_get_tracks()) {
      mutable_get_tracks()->::CollectionRequest_GetTrackList::MergeFrom(from.get_tracks());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollectionRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollectionRequest::CopyFrom(const CollectionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectionRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CollectionRequest::Swap(CollectionRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(get_genres_, other->get_genres_);
    std::swap(get_artists_, other->get_artists_);
    std::swap(get_releases_, other->get_releases_);
    std::swap(get_tracks_, other->get_tracks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollectionRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollectionRequest_descriptor_;
  metadata.reflection = CollectionRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* CollectionResponse_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionResponse_Type_descriptor_;
}
bool CollectionResponse_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CollectionResponse_Type CollectionResponse::TypeGenreList;
const CollectionResponse_Type CollectionResponse::TypeArtistList;
const CollectionResponse_Type CollectionResponse::TypeReleaseList;
const CollectionResponse_Type CollectionResponse::TypeTrackList;
const CollectionResponse_Type CollectionResponse::Type_MIN;
const CollectionResponse_Type CollectionResponse::Type_MAX;
const int CollectionResponse::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CollectionResponse::kErrorFieldNumber;
const int CollectionResponse::kTypeFieldNumber;
const int CollectionResponse::kGenreListFieldNumber;
const int CollectionResponse::kArtistListFieldNumber;
const int CollectionResponse::kReleaseListFieldNumber;
const int CollectionResponse::kTrackListFieldNumber;
#endif  // !_MSC_VER

CollectionResponse::CollectionResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CollectionResponse::InitAsDefaultInstance() {
  error_ = const_cast< ::Error*>(&::Error::default_instance());
  genre_list_ = const_cast< ::GenreList*>(&::GenreList::default_instance());
  artist_list_ = const_cast< ::ArtistList*>(&::ArtistList::default_instance());
  release_list_ = const_cast< ::ReleaseList*>(&::ReleaseList::default_instance());
  track_list_ = const_cast< ::TrackList*>(&::TrackList::default_instance());
}

CollectionResponse::CollectionResponse(const CollectionResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CollectionResponse::SharedCtor() {
  _cached_size_ = 0;
  error_ = NULL;
  type_ = 1;
  genre_list_ = NULL;
  artist_list_ = NULL;
  release_list_ = NULL;
  track_list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CollectionResponse::~CollectionResponse() {
  SharedDtor();
}

void CollectionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
    delete genre_list_;
    delete artist_list_;
    delete release_list_;
    delete track_list_;
  }
}

void CollectionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CollectionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CollectionResponse_descriptor_;
}

const CollectionResponse& CollectionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

CollectionResponse* CollectionResponse::default_instance_ = NULL;

CollectionResponse* CollectionResponse::New() const {
  return new CollectionResponse;
}

void CollectionResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_error()) {
      if (error_ != NULL) error_->::Error::Clear();
    }
    type_ = 1;
    if (has_genre_list()) {
      if (genre_list_ != NULL) genre_list_->::GenreList::Clear();
    }
    if (has_artist_list()) {
      if (artist_list_ != NULL) artist_list_->::ArtistList::Clear();
    }
    if (has_release_list()) {
      if (release_list_ != NULL) release_list_->::ReleaseList::Clear();
    }
    if (has_track_list()) {
      if (track_list_ != NULL) track_list_->::TrackList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CollectionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Error error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .CollectionResponse.Type type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::CollectionResponse_Type_IsValid(value)) {
            set_type(static_cast< ::CollectionResponse_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_genre_list;
        break;
      }

      // optional .GenreList genre_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genre_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_genre_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_artist_list;
        break;
      }

      // optional .ArtistList artist_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_artist_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_release_list;
        break;
      }

      // optional .ReleaseList release_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_release_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_track_list;
        break;
      }

      // optional .TrackList track_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_track_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_track_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CollectionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Error error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->error(), output);
  }

  // optional .CollectionResponse.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .GenreList genre_list = 3;
  if (has_genre_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->genre_list(), output);
  }

  // optional .ArtistList artist_list = 4;
  if (has_artist_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->artist_list(), output);
  }

  // optional .ReleaseList release_list = 5;
  if (has_release_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->release_list(), output);
  }

  // optional .TrackList track_list = 6;
  if (has_track_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->track_list(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CollectionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Error error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->error(), target);
  }

  // optional .CollectionResponse.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .GenreList genre_list = 3;
  if (has_genre_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->genre_list(), target);
  }

  // optional .ArtistList artist_list = 4;
  if (has_artist_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->artist_list(), target);
  }

  // optional .ReleaseList release_list = 5;
  if (has_release_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->release_list(), target);
  }

  // optional .TrackList track_list = 6;
  if (has_track_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->track_list(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CollectionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Error error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

    // optional .CollectionResponse.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .GenreList genre_list = 3;
    if (has_genre_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->genre_list());
    }

    // optional .ArtistList artist_list = 4;
    if (has_artist_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->artist_list());
    }

    // optional .ReleaseList release_list = 5;
    if (has_release_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->release_list());
    }

    // optional .TrackList track_list = 6;
    if (has_track_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->track_list());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CollectionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CollectionResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CollectionResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CollectionResponse::MergeFrom(const CollectionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      mutable_error()->::Error::MergeFrom(from.error());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_genre_list()) {
      mutable_genre_list()->::GenreList::MergeFrom(from.genre_list());
    }
    if (from.has_artist_list()) {
      mutable_artist_list()->::ArtistList::MergeFrom(from.artist_list());
    }
    if (from.has_release_list()) {
      mutable_release_list()->::ReleaseList::MergeFrom(from.release_list());
    }
    if (from.has_track_list()) {
      mutable_track_list()->::TrackList::MergeFrom(from.track_list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CollectionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CollectionResponse::CopyFrom(const CollectionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CollectionResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  if (has_genre_list()) {
    if (!this->genre_list().IsInitialized()) return false;
  }
  if (has_artist_list()) {
    if (!this->artist_list().IsInitialized()) return false;
  }
  if (has_release_list()) {
    if (!this->release_list().IsInitialized()) return false;
  }
  if (has_track_list()) {
    if (!this->track_list().IsInitialized()) return false;
  }
  return true;
}

void CollectionResponse::Swap(CollectionResponse* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(type_, other->type_);
    std::swap(genre_list_, other->genre_list_);
    std::swap(artist_list_, other->artist_list_);
    std::swap(release_list_, other->release_list_);
    std::swap(track_list_, other->track_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CollectionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CollectionResponse_descriptor_;
  metadata.reflection = CollectionResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GenreList::kLastFieldNumber;
const int GenreList::kGenresFieldNumber;
#endif  // !_MSC_VER

GenreList::GenreList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GenreList::InitAsDefaultInstance() {
}

GenreList::GenreList(const GenreList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GenreList::SharedCtor() {
  _cached_size_ = 0;
  last_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GenreList::~GenreList() {
  SharedDtor();
}

void GenreList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GenreList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GenreList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GenreList_descriptor_;
}

const GenreList& GenreList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

GenreList* GenreList::default_instance_ = NULL;

GenreList* GenreList::New() const {
  return new GenreList;
}

void GenreList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    last_ = false;
  }
  genres_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GenreList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool last = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &last_)));
          set_has_last();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_genres;
        break;
      }

      // repeated .Genre genres = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_genres()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_genres;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GenreList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool last = 1;
  if (has_last()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->last(), output);
  }

  // repeated .Genre genres = 2;
  for (int i = 0; i < this->genres_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->genres(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GenreList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool last = 1;
  if (has_last()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->last(), target);
  }

  // repeated .Genre genres = 2;
  for (int i = 0; i < this->genres_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->genres(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GenreList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool last = 1;
    if (has_last()) {
      total_size += 1 + 1;
    }

  }
  // repeated .Genre genres = 2;
  total_size += 1 * this->genres_size();
  for (int i = 0; i < this->genres_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->genres(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GenreList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GenreList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GenreList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GenreList::MergeFrom(const GenreList& from) {
  GOOGLE_CHECK_NE(&from, this);
  genres_.MergeFrom(from.genres_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_last()) {
      set_last(from.last());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GenreList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GenreList::CopyFrom(const GenreList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenreList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < genres_size(); i++) {
    if (!this->genres(i).IsInitialized()) return false;
  }
  return true;
}

void GenreList::Swap(GenreList* other) {
  if (other != this) {
    std::swap(last_, other->last_);
    genres_.Swap(&other->genres_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GenreList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GenreList_descriptor_;
  metadata.reflection = GenreList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ArtistList::kLastFieldNumber;
const int ArtistList::kArtistsFieldNumber;
#endif  // !_MSC_VER

ArtistList::ArtistList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ArtistList::InitAsDefaultInstance() {
}

ArtistList::ArtistList(const ArtistList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ArtistList::SharedCtor() {
  _cached_size_ = 0;
  last_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ArtistList::~ArtistList() {
  SharedDtor();
}

void ArtistList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ArtistList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ArtistList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ArtistList_descriptor_;
}

const ArtistList& ArtistList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

ArtistList* ArtistList::default_instance_ = NULL;

ArtistList* ArtistList::New() const {
  return new ArtistList;
}

void ArtistList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    last_ = false;
  }
  artists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ArtistList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool last = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &last_)));
          set_has_last();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artists;
        break;
      }

      // repeated .Artist artists = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_artists()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artists;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ArtistList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool last = 1;
  if (has_last()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->last(), output);
  }

  // repeated .Artist artists = 2;
  for (int i = 0; i < this->artists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->artists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ArtistList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool last = 1;
  if (has_last()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->last(), target);
  }

  // repeated .Artist artists = 2;
  for (int i = 0; i < this->artists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->artists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ArtistList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool last = 1;
    if (has_last()) {
      total_size += 1 + 1;
    }

  }
  // repeated .Artist artists = 2;
  total_size += 1 * this->artists_size();
  for (int i = 0; i < this->artists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->artists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ArtistList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ArtistList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ArtistList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ArtistList::MergeFrom(const ArtistList& from) {
  GOOGLE_CHECK_NE(&from, this);
  artists_.MergeFrom(from.artists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_last()) {
      set_last(from.last());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ArtistList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ArtistList::CopyFrom(const ArtistList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ArtistList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < artists_size(); i++) {
    if (!this->artists(i).IsInitialized()) return false;
  }
  return true;
}

void ArtistList::Swap(ArtistList* other) {
  if (other != this) {
    std::swap(last_, other->last_);
    artists_.Swap(&other->artists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ArtistList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ArtistList_descriptor_;
  metadata.reflection = ArtistList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReleaseList::kLastFieldNumber;
const int ReleaseList::kReleasesFieldNumber;
#endif  // !_MSC_VER

ReleaseList::ReleaseList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReleaseList::InitAsDefaultInstance() {
}

ReleaseList::ReleaseList(const ReleaseList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReleaseList::SharedCtor() {
  _cached_size_ = 0;
  last_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReleaseList::~ReleaseList() {
  SharedDtor();
}

void ReleaseList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReleaseList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReleaseList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReleaseList_descriptor_;
}

const ReleaseList& ReleaseList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

ReleaseList* ReleaseList::default_instance_ = NULL;

ReleaseList* ReleaseList::New() const {
  return new ReleaseList;
}

void ReleaseList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    last_ = false;
  }
  releases_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReleaseList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool last = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &last_)));
          set_has_last();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_releases;
        break;
      }

      // repeated .Release releases = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_releases:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_releases()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_releases;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReleaseList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool last = 1;
  if (has_last()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->last(), output);
  }

  // repeated .Release releases = 2;
  for (int i = 0; i < this->releases_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->releases(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReleaseList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool last = 1;
  if (has_last()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->last(), target);
  }

  // repeated .Release releases = 2;
  for (int i = 0; i < this->releases_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->releases(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReleaseList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool last = 1;
    if (has_last()) {
      total_size += 1 + 1;
    }

  }
  // repeated .Release releases = 2;
  total_size += 1 * this->releases_size();
  for (int i = 0; i < this->releases_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->releases(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReleaseList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReleaseList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReleaseList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReleaseList::MergeFrom(const ReleaseList& from) {
  GOOGLE_CHECK_NE(&from, this);
  releases_.MergeFrom(from.releases_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_last()) {
      set_last(from.last());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReleaseList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReleaseList::CopyFrom(const ReleaseList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReleaseList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < releases_size(); i++) {
    if (!this->releases(i).IsInitialized()) return false;
  }
  return true;
}

void ReleaseList::Swap(ReleaseList* other) {
  if (other != this) {
    std::swap(last_, other->last_);
    releases_.Swap(&other->releases_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReleaseList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReleaseList_descriptor_;
  metadata.reflection = ReleaseList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TrackList::kLastFieldNumber;
const int TrackList::kTracksFieldNumber;
#endif  // !_MSC_VER

TrackList::TrackList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TrackList::InitAsDefaultInstance() {
}

TrackList::TrackList(const TrackList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TrackList::SharedCtor() {
  _cached_size_ = 0;
  last_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrackList::~TrackList() {
  SharedDtor();
}

void TrackList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TrackList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrackList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrackList_descriptor_;
}

const TrackList& TrackList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

TrackList* TrackList::default_instance_ = NULL;

TrackList* TrackList::New() const {
  return new TrackList;
}

void TrackList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    last_ = false;
  }
  tracks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TrackList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool last = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &last_)));
          set_has_last();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tracks;
        break;
      }

      // repeated .Track tracks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tracks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tracks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tracks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TrackList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool last = 1;
  if (has_last()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->last(), output);
  }

  // repeated .Track tracks = 2;
  for (int i = 0; i < this->tracks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tracks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TrackList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool last = 1;
  if (has_last()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->last(), target);
  }

  // repeated .Track tracks = 2;
  for (int i = 0; i < this->tracks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tracks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TrackList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool last = 1;
    if (has_last()) {
      total_size += 1 + 1;
    }

  }
  // repeated .Track tracks = 2;
  total_size += 1 * this->tracks_size();
  for (int i = 0; i < this->tracks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tracks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrackList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TrackList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TrackList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TrackList::MergeFrom(const TrackList& from) {
  GOOGLE_CHECK_NE(&from, this);
  tracks_.MergeFrom(from.tracks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_last()) {
      set_last(from.last());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TrackList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrackList::CopyFrom(const TrackList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < tracks_size(); i++) {
    if (!this->tracks(i).IsInitialized()) return false;
  }
  return true;
}

void TrackList::Swap(TrackList* other) {
  if (other != this) {
    std::swap(last_, other->last_);
    tracks_.Swap(&other->tracks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TrackList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrackList_descriptor_;
  metadata.reflection = TrackList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Genre::kNameFieldNumber;
#endif  // !_MSC_VER

Genre::Genre()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Genre::InitAsDefaultInstance() {
}

Genre::Genre(const Genre& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Genre::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Genre::~Genre() {
  SharedDtor();
}

void Genre::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Genre::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Genre::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Genre_descriptor_;
}

const Genre& Genre::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

Genre* Genre::default_instance_ = NULL;

Genre* Genre::New() const {
  return new Genre;
}

void Genre::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Genre::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Genre::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Genre::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Genre::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Genre::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Genre* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Genre*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Genre::MergeFrom(const Genre& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Genre::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Genre::CopyFrom(const Genre& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Genre::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Genre::Swap(Genre* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Genre::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Genre_descriptor_;
  metadata.reflection = Genre_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CoverArt::kMimeTypeFieldNumber;
const int CoverArt::kDataFieldNumber;
#endif  // !_MSC_VER

CoverArt::CoverArt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CoverArt::InitAsDefaultInstance() {
}

CoverArt::CoverArt(const CoverArt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CoverArt::SharedCtor() {
  _cached_size_ = 0;
  mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CoverArt::~CoverArt() {
  SharedDtor();
}

void CoverArt::SharedDtor() {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    delete mime_type_;
  }
  if (this != default_instance_) {
  }
}

void CoverArt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CoverArt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CoverArt_descriptor_;
}

const CoverArt& CoverArt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

CoverArt* CoverArt::default_instance_ = NULL;

CoverArt* CoverArt::New() const {
  return new CoverArt;
}

void CoverArt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mime_type()) {
      if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
        mime_type_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CoverArt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string mime_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mime_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mime_type().data(), this->mime_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated bytes data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CoverArt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string mime_type = 1;
  if (has_mime_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mime_type().data(), this->mime_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mime_type(), output);
  }

  // repeated bytes data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CoverArt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string mime_type = 1;
  if (has_mime_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mime_type().data(), this->mime_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mime_type(), target);
  }

  // repeated bytes data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CoverArt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string mime_type = 1;
    if (has_mime_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mime_type());
    }

  }
  // repeated bytes data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CoverArt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CoverArt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CoverArt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CoverArt::MergeFrom(const CoverArt& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mime_type()) {
      set_mime_type(from.mime_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CoverArt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CoverArt::CopyFrom(const CoverArt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoverArt::IsInitialized() const {

  return true;
}

void CoverArt::Swap(CoverArt* other) {
  if (other != this) {
    std::swap(mime_type_, other->mime_type_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CoverArt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CoverArt_descriptor_;
  metadata.reflection = CoverArt_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Artist::kNameFieldNumber;
const int Artist::kNbReleasesFieldNumber;
#endif  // !_MSC_VER

Artist::Artist()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Artist::InitAsDefaultInstance() {
}

Artist::Artist(const Artist& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Artist::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nb_releases_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Artist::~Artist() {
  SharedDtor();
}

void Artist::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Artist::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Artist::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Artist_descriptor_;
}

const Artist& Artist::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

Artist* Artist::default_instance_ = NULL;

Artist* Artist::New() const {
  return new Artist;
}

void Artist::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    nb_releases_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Artist::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nb_releases;
        break;
      }

      // required uint32 nb_releases = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nb_releases:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nb_releases_)));
          set_has_nb_releases();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Artist::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required uint32 nb_releases = 2;
  if (has_nb_releases()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->nb_releases(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Artist::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 nb_releases = 2;
  if (has_nb_releases()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->nb_releases(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Artist::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 nb_releases = 2;
    if (has_nb_releases()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nb_releases());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Artist::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Artist* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Artist*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Artist::MergeFrom(const Artist& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_nb_releases()) {
      set_nb_releases(from.nb_releases());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Artist::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Artist::CopyFrom(const Artist& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Artist::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Artist::Swap(Artist* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(nb_releases_, other->nb_releases_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Artist::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Artist_descriptor_;
  metadata.reflection = Artist_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Release::kNameFieldNumber;
const int Release::kNbTracksFieldNumber;
const int Release::kDurationSecsFieldNumber;
const int Release::kCoverArtFieldNumber;
#endif  // !_MSC_VER

Release::Release()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Release::InitAsDefaultInstance() {
  coverart_ = const_cast< ::CoverArt*>(&::CoverArt::default_instance());
}

Release::Release(const Release& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Release::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nb_tracks_ = 0u;
  duration_secs_ = 0u;
  coverart_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Release::~Release() {
  SharedDtor();
}

void Release::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete coverart_;
  }
}

void Release::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Release::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Release_descriptor_;
}

const Release& Release::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

Release* Release::default_instance_ = NULL;

Release* Release::New() const {
  return new Release;
}

void Release::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    nb_tracks_ = 0u;
    duration_secs_ = 0u;
    if (has_coverart()) {
      if (coverart_ != NULL) coverart_->::CoverArt::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Release::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nb_tracks;
        break;
      }

      // required uint32 nb_tracks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nb_tracks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nb_tracks_)));
          set_has_nb_tracks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_duration_secs;
        break;
      }

      // required uint32 duration_secs = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_secs_)));
          set_has_duration_secs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_coverArt;
        break;
      }

      // optional .CoverArt coverArt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coverArt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coverart()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Release::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required uint32 nb_tracks = 2;
  if (has_nb_tracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->nb_tracks(), output);
  }

  // required uint32 duration_secs = 3;
  if (has_duration_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->duration_secs(), output);
  }

  // optional .CoverArt coverArt = 4;
  if (has_coverart()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->coverart(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Release::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 nb_tracks = 2;
  if (has_nb_tracks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->nb_tracks(), target);
  }

  // required uint32 duration_secs = 3;
  if (has_duration_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->duration_secs(), target);
  }

  // optional .CoverArt coverArt = 4;
  if (has_coverart()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->coverart(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Release::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 nb_tracks = 2;
    if (has_nb_tracks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nb_tracks());
    }

    // required uint32 duration_secs = 3;
    if (has_duration_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration_secs());
    }

    // optional .CoverArt coverArt = 4;
    if (has_coverart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coverart());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Release::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Release* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Release*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Release::MergeFrom(const Release& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_nb_tracks()) {
      set_nb_tracks(from.nb_tracks());
    }
    if (from.has_duration_secs()) {
      set_duration_secs(from.duration_secs());
    }
    if (from.has_coverart()) {
      mutable_coverart()->::CoverArt::MergeFrom(from.coverart());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Release::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Release::CopyFrom(const Release& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Release::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Release::Swap(Release* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(nb_tracks_, other->nb_tracks_);
    std::swap(duration_secs_, other->duration_secs_);
    std::swap(coverart_, other->coverart_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Release::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Release_descriptor_;
  metadata.reflection = Release_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Track::kMediaIdFieldNumber;
const int Track::kDiscNumberFieldNumber;
const int Track::kTrackNumberFieldNumber;
const int Track::kArtistFieldNumber;
const int Track::kReleaseFieldNumber;
const int Track::kNameFieldNumber;
const int Track::kDurationSecsFieldNumber;
const int Track::kReleaseDateFieldNumber;
const int Track::kOriginalReleaseDateFieldNumber;
const int Track::kGenresFieldNumber;
const int Track::kCoverArtFieldNumber;
#endif  // !_MSC_VER

Track::Track()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Track::InitAsDefaultInstance() {
}

Track::Track(const Track& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Track::SharedCtor() {
  _cached_size_ = 0;
  media_id_ = GOOGLE_LONGLONG(0);
  disc_number_ = 0u;
  track_number_ = 0u;
  artist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  release_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  duration_secs_ = 0u;
  release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  original_release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  coverart_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Track::~Track() {
  SharedDtor();
}

void Track::SharedDtor() {
  if (artist_ != &::google::protobuf::internal::kEmptyString) {
    delete artist_;
  }
  if (release_ != &::google::protobuf::internal::kEmptyString) {
    delete release_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete release_date_;
  }
  if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete original_release_date_;
  }
  if (coverart_ != &::google::protobuf::internal::kEmptyString) {
    delete coverart_;
  }
  if (this != default_instance_) {
  }
}

void Track::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Track::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Track_descriptor_;
}

const Track& Track::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

Track* Track::default_instance_ = NULL;

Track* Track::New() const {
  return new Track;
}

void Track::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    media_id_ = GOOGLE_LONGLONG(0);
    disc_number_ = 0u;
    track_number_ = 0u;
    if (has_artist()) {
      if (artist_ != &::google::protobuf::internal::kEmptyString) {
        artist_->clear();
      }
    }
    if (has_release()) {
      if (release_ != &::google::protobuf::internal::kEmptyString) {
        release_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    duration_secs_ = 0u;
    if (has_release_date()) {
      if (release_date_ != &::google::protobuf::internal::kEmptyString) {
        release_date_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_original_release_date()) {
      if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
        original_release_date_->clear();
      }
    }
    if (has_coverart()) {
      if (coverart_ != &::google::protobuf::internal::kEmptyString) {
        coverart_->clear();
      }
    }
  }
  genres_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Track::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 media_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &media_id_)));
          set_has_media_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_disc_number;
        break;
      }

      // optional uint32 disc_number = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_disc_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &disc_number_)));
          set_has_disc_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_track_number;
        break;
      }

      // optional uint32 track_number = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_track_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &track_number_)));
          set_has_track_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_artist;
        break;
      }

      // optional string artist = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_artist()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist().data(), this->artist().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_release;
        break;
      }

      // optional string release = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_release()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release().data(), this->release().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_name;
        break;
      }

      // required string name = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_duration_secs;
        break;
      }

      // required uint32 duration_secs = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_secs_)));
          set_has_duration_secs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_release_date;
        break;
      }

      // optional string release_date = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_release_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release_date().data(), this->release_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_original_release_date;
        break;
      }

      // optional string original_release_date = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_original_release_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_original_release_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->original_release_date().data(), this->original_release_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_genres;
        break;
      }

      // repeated string genres = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_genres()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->genres(this->genres_size() - 1).data(),
            this->genres(this->genres_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_genres;
        if (input->ExpectTag(90)) goto parse_coverArt;
        break;
      }

      // optional bytes coverArt = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coverArt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_coverart()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Track::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 media_id = 1;
  if (has_media_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->media_id(), output);
  }

  // optional uint32 disc_number = 2;
  if (has_disc_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->disc_number(), output);
  }

  // optional uint32 track_number = 3;
  if (has_track_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->track_number(), output);
  }

  // optional string artist = 4;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->artist(), output);
  }

  // optional string release = 5;
  if (has_release()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release().data(), this->release().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->release(), output);
  }

  // required string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->name(), output);
  }

  // required uint32 duration_secs = 7;
  if (has_duration_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->duration_secs(), output);
  }

  // optional string release_date = 8;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->release_date(), output);
  }

  // optional string original_release_date = 9;
  if (has_original_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->original_release_date().data(), this->original_release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->original_release_date(), output);
  }

  // repeated string genres = 10;
  for (int i = 0; i < this->genres_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->genres(i).data(), this->genres(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->genres(i), output);
  }

  // optional bytes coverArt = 11;
  if (has_coverart()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->coverart(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Track::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 media_id = 1;
  if (has_media_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->media_id(), target);
  }

  // optional uint32 disc_number = 2;
  if (has_disc_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->disc_number(), target);
  }

  // optional uint32 track_number = 3;
  if (has_track_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->track_number(), target);
  }

  // optional string artist = 4;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->artist(), target);
  }

  // optional string release = 5;
  if (has_release()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release().data(), this->release().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->release(), target);
  }

  // required string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->name(), target);
  }

  // required uint32 duration_secs = 7;
  if (has_duration_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->duration_secs(), target);
  }

  // optional string release_date = 8;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->release_date(), target);
  }

  // optional string original_release_date = 9;
  if (has_original_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->original_release_date().data(), this->original_release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->original_release_date(), target);
  }

  // repeated string genres = 10;
  for (int i = 0; i < this->genres_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->genres(i).data(), this->genres(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(10, this->genres(i), target);
  }

  // optional bytes coverArt = 11;
  if (has_coverart()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->coverart(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Track::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 media_id = 1;
    if (has_media_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->media_id());
    }

    // optional uint32 disc_number = 2;
    if (has_disc_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->disc_number());
    }

    // optional uint32 track_number = 3;
    if (has_track_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->track_number());
    }

    // optional string artist = 4;
    if (has_artist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->artist());
    }

    // optional string release = 5;
    if (has_release()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->release());
    }

    // required string name = 6;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 duration_secs = 7;
    if (has_duration_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration_secs());
    }

    // optional string release_date = 8;
    if (has_release_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->release_date());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string original_release_date = 9;
    if (has_original_release_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->original_release_date());
    }

    // optional bytes coverArt = 11;
    if (has_coverart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->coverart());
    }

  }
  // repeated string genres = 10;
  total_size += 1 * this->genres_size();
  for (int i = 0; i < this->genres_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->genres(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Track::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Track* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Track*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Track::MergeFrom(const Track& from) {
  GOOGLE_CHECK_NE(&from, this);
  genres_.MergeFrom(from.genres_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_media_id()) {
      set_media_id(from.media_id());
    }
    if (from.has_disc_number()) {
      set_disc_number(from.disc_number());
    }
    if (from.has_track_number()) {
      set_track_number(from.track_number());
    }
    if (from.has_artist()) {
      set_artist(from.artist());
    }
    if (from.has_release()) {
      set_release(from.release());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_duration_secs()) {
      set_duration_secs(from.duration_secs());
    }
    if (from.has_release_date()) {
      set_release_date(from.release_date());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_original_release_date()) {
      set_original_release_date(from.original_release_date());
    }
    if (from.has_coverart()) {
      set_coverart(from.coverart());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Track::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Track::CopyFrom(const Track& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Track::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000061) != 0x00000061) return false;

  return true;
}

void Track::Swap(Track* other) {
  if (other != this) {
    std::swap(media_id_, other->media_id_);
    std::swap(disc_number_, other->disc_number_);
    std::swap(track_number_, other->track_number_);
    std::swap(artist_, other->artist_);
    std::swap(release_, other->release_);
    std::swap(name_, other->name_);
    std::swap(duration_secs_, other->duration_secs_);
    std::swap(release_date_, other->release_date_);
    std::swap(original_release_date_, other->original_release_date_);
    genres_.Swap(&other->genres_);
    std::swap(coverart_, other->coverart_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Track::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Track_descriptor_;
  metadata.reflection = Track_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
