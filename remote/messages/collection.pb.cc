// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collection.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "collection.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Remote {

namespace {

const ::google::protobuf::Descriptor* AudioCollectionRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_BatchParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_BatchParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetGenreList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetGenreList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetArtistList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetArtistList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetReleaseList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetReleaseList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetTrackList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetTrackList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetCoverArt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetCoverArt_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_GetCoverArt_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Revision_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Revision_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_GenreList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_GenreList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_ArtistList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_ArtistList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_ReleaseList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_ReleaseList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_TrackList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_TrackList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_CoverArt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_CoverArt_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Genre_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Genre_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Artist_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Artist_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Release_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Release_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Track_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Track_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AudioCollectionResponse_Type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_collection_2eproto() {
  protobuf_AddDesc_collection_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "collection.proto");
  GOOGLE_CHECK(file != NULL);
  AudioCollectionRequest_descriptor_ = file->message_type(0);
  static const int AudioCollectionRequest_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_genres_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_artists_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_releases_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_tracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_cover_art_),
  };
  AudioCollectionRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_descriptor_,
      AudioCollectionRequest::default_instance_,
      AudioCollectionRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest));
  AudioCollectionRequest_BatchParameter_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(0);
  static const int AudioCollectionRequest_BatchParameter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, size_),
  };
  AudioCollectionRequest_BatchParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_BatchParameter_descriptor_,
      AudioCollectionRequest_BatchParameter::default_instance_,
      AudioCollectionRequest_BatchParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_BatchParameter));
  AudioCollectionRequest_GetGenreList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(1);
  static const int AudioCollectionRequest_GetGenreList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetGenreList, batch_parameter_),
  };
  AudioCollectionRequest_GetGenreList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetGenreList_descriptor_,
      AudioCollectionRequest_GetGenreList::default_instance_,
      AudioCollectionRequest_GetGenreList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetGenreList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetGenreList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetGenreList));
  AudioCollectionRequest_GetArtistList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(2);
  static const int AudioCollectionRequest_GetArtistList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, batch_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, genre_id_),
  };
  AudioCollectionRequest_GetArtistList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetArtistList_descriptor_,
      AudioCollectionRequest_GetArtistList::default_instance_,
      AudioCollectionRequest_GetArtistList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetArtistList));
  AudioCollectionRequest_GetReleaseList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(3);
  static const int AudioCollectionRequest_GetReleaseList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, batch_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, artist_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, filter_genre_),
  };
  AudioCollectionRequest_GetReleaseList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetReleaseList_descriptor_,
      AudioCollectionRequest_GetReleaseList::default_instance_,
      AudioCollectionRequest_GetReleaseList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetReleaseList));
  AudioCollectionRequest_GetTrackList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(4);
  static const int AudioCollectionRequest_GetTrackList_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, batch_parameter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, artist_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, release_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, genre_id_),
  };
  AudioCollectionRequest_GetTrackList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetTrackList_descriptor_,
      AudioCollectionRequest_GetTrackList::default_instance_,
      AudioCollectionRequest_GetTrackList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetTrackList));
  AudioCollectionRequest_GetCoverArt_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(5);
  static const int AudioCollectionRequest_GetCoverArt_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetCoverArt, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetCoverArt, release_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetCoverArt, track_id_),
  };
  AudioCollectionRequest_GetCoverArt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetCoverArt_descriptor_,
      AudioCollectionRequest_GetCoverArt::default_instance_,
      AudioCollectionRequest_GetCoverArt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetCoverArt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetCoverArt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetCoverArt));
  AudioCollectionRequest_GetCoverArt_Type_descriptor_ = AudioCollectionRequest_GetCoverArt_descriptor_->enum_type(0);
  AudioCollectionRequest_Type_descriptor_ = AudioCollectionRequest_descriptor_->enum_type(0);
  AudioCollectionResponse_descriptor_ = file->message_type(1);
  static const int AudioCollectionResponse_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, revision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, genre_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, artist_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, release_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, track_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, cover_art_),
  };
  AudioCollectionResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_descriptor_,
      AudioCollectionResponse::default_instance_,
      AudioCollectionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse));
  AudioCollectionResponse_Revision_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(0);
  static const int AudioCollectionResponse_Revision_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Revision, rev_),
  };
  AudioCollectionResponse_Revision_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Revision_descriptor_,
      AudioCollectionResponse_Revision::default_instance_,
      AudioCollectionResponse_Revision_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Revision, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Revision, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Revision));
  AudioCollectionResponse_GenreList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(1);
  static const int AudioCollectionResponse_GenreList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_GenreList, genres_),
  };
  AudioCollectionResponse_GenreList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_GenreList_descriptor_,
      AudioCollectionResponse_GenreList::default_instance_,
      AudioCollectionResponse_GenreList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_GenreList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_GenreList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_GenreList));
  AudioCollectionResponse_ArtistList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(2);
  static const int AudioCollectionResponse_ArtistList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ArtistList, artists_),
  };
  AudioCollectionResponse_ArtistList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_ArtistList_descriptor_,
      AudioCollectionResponse_ArtistList::default_instance_,
      AudioCollectionResponse_ArtistList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ArtistList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ArtistList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_ArtistList));
  AudioCollectionResponse_ReleaseList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(3);
  static const int AudioCollectionResponse_ReleaseList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ReleaseList, releases_),
  };
  AudioCollectionResponse_ReleaseList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_ReleaseList_descriptor_,
      AudioCollectionResponse_ReleaseList::default_instance_,
      AudioCollectionResponse_ReleaseList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ReleaseList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ReleaseList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_ReleaseList));
  AudioCollectionResponse_TrackList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(4);
  static const int AudioCollectionResponse_TrackList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_TrackList, tracks_),
  };
  AudioCollectionResponse_TrackList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_TrackList_descriptor_,
      AudioCollectionResponse_TrackList::default_instance_,
      AudioCollectionResponse_TrackList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_TrackList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_TrackList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_TrackList));
  AudioCollectionResponse_CoverArt_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(5);
  static const int AudioCollectionResponse_CoverArt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, mime_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, data_),
  };
  AudioCollectionResponse_CoverArt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_CoverArt_descriptor_,
      AudioCollectionResponse_CoverArt::default_instance_,
      AudioCollectionResponse_CoverArt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_CoverArt));
  AudioCollectionResponse_Genre_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(6);
  static const int AudioCollectionResponse_Genre_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Genre, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Genre, name_),
  };
  AudioCollectionResponse_Genre_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Genre_descriptor_,
      AudioCollectionResponse_Genre::default_instance_,
      AudioCollectionResponse_Genre_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Genre, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Genre, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Genre));
  AudioCollectionResponse_Artist_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(7);
  static const int AudioCollectionResponse_Artist_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, nb_releases_),
  };
  AudioCollectionResponse_Artist_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Artist_descriptor_,
      AudioCollectionResponse_Artist::default_instance_,
      AudioCollectionResponse_Artist_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Artist));
  AudioCollectionResponse_Release_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(8);
  static const int AudioCollectionResponse_Release_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, nb_tracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, duration_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, release_date_),
  };
  AudioCollectionResponse_Release_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Release_descriptor_,
      AudioCollectionResponse_Release::default_instance_,
      AudioCollectionResponse_Release_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Release));
  AudioCollectionResponse_Track_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(9);
  static const int AudioCollectionResponse_Track_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, artist_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, release_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, genre_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, disc_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, track_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, duration_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, release_date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, original_release_date_),
  };
  AudioCollectionResponse_Track_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Track_descriptor_,
      AudioCollectionResponse_Track::default_instance_,
      AudioCollectionResponse_Track_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Track));
  AudioCollectionResponse_Type_descriptor_ = AudioCollectionResponse_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_collection_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_descriptor_, &AudioCollectionRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_BatchParameter_descriptor_, &AudioCollectionRequest_BatchParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetGenreList_descriptor_, &AudioCollectionRequest_GetGenreList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetArtistList_descriptor_, &AudioCollectionRequest_GetArtistList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetReleaseList_descriptor_, &AudioCollectionRequest_GetReleaseList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetTrackList_descriptor_, &AudioCollectionRequest_GetTrackList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetCoverArt_descriptor_, &AudioCollectionRequest_GetCoverArt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_descriptor_, &AudioCollectionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Revision_descriptor_, &AudioCollectionResponse_Revision::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_GenreList_descriptor_, &AudioCollectionResponse_GenreList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_ArtistList_descriptor_, &AudioCollectionResponse_ArtistList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_ReleaseList_descriptor_, &AudioCollectionResponse_ReleaseList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_TrackList_descriptor_, &AudioCollectionResponse_TrackList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_CoverArt_descriptor_, &AudioCollectionResponse_CoverArt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Genre_descriptor_, &AudioCollectionResponse_Genre::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Artist_descriptor_, &AudioCollectionResponse_Artist::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Release_descriptor_, &AudioCollectionResponse_Release::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Track_descriptor_, &AudioCollectionResponse_Track::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_collection_2eproto() {
  delete AudioCollectionRequest::default_instance_;
  delete AudioCollectionRequest_reflection_;
  delete AudioCollectionRequest_BatchParameter::default_instance_;
  delete AudioCollectionRequest_BatchParameter_reflection_;
  delete AudioCollectionRequest_GetGenreList::default_instance_;
  delete AudioCollectionRequest_GetGenreList_reflection_;
  delete AudioCollectionRequest_GetArtistList::default_instance_;
  delete AudioCollectionRequest_GetArtistList_reflection_;
  delete AudioCollectionRequest_GetReleaseList::default_instance_;
  delete AudioCollectionRequest_GetReleaseList_reflection_;
  delete AudioCollectionRequest_GetTrackList::default_instance_;
  delete AudioCollectionRequest_GetTrackList_reflection_;
  delete AudioCollectionRequest_GetCoverArt::default_instance_;
  delete AudioCollectionRequest_GetCoverArt_reflection_;
  delete AudioCollectionResponse::default_instance_;
  delete AudioCollectionResponse_reflection_;
  delete AudioCollectionResponse_Revision::default_instance_;
  delete AudioCollectionResponse_Revision_reflection_;
  delete AudioCollectionResponse_GenreList::default_instance_;
  delete AudioCollectionResponse_GenreList_reflection_;
  delete AudioCollectionResponse_ArtistList::default_instance_;
  delete AudioCollectionResponse_ArtistList_reflection_;
  delete AudioCollectionResponse_ReleaseList::default_instance_;
  delete AudioCollectionResponse_ReleaseList_reflection_;
  delete AudioCollectionResponse_TrackList::default_instance_;
  delete AudioCollectionResponse_TrackList_reflection_;
  delete AudioCollectionResponse_CoverArt::default_instance_;
  delete AudioCollectionResponse_CoverArt_reflection_;
  delete AudioCollectionResponse_Genre::default_instance_;
  delete AudioCollectionResponse_Genre_reflection_;
  delete AudioCollectionResponse_Artist::default_instance_;
  delete AudioCollectionResponse_Artist_reflection_;
  delete AudioCollectionResponse_Release::default_instance_;
  delete AudioCollectionResponse_Release_reflection_;
  delete AudioCollectionResponse_Track::default_instance_;
  delete AudioCollectionResponse_Track_reflection_;
}

void protobuf_AddDesc_collection_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Remote::protobuf_AddDesc_common_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020collection.proto\022\006Remote\032\014common.proto"
    "\"\342\t\n\026AudioCollectionRequest\0221\n\004type\030\001 \002("
    "\0162#.Remote.AudioCollectionRequest.Type\022\?"
    "\n\nget_genres\030\002 \001(\0132+.Remote.AudioCollect"
    "ionRequest.GetGenreList\022A\n\013get_artists\030\003"
    " \001(\0132,.Remote.AudioCollectionRequest.Get"
    "ArtistList\022C\n\014get_releases\030\004 \001(\0132-.Remot"
    "e.AudioCollectionRequest.GetReleaseList\022"
    "\?\n\nget_tracks\030\005 \001(\0132+.Remote.AudioCollec"
    "tionRequest.GetTrackList\022A\n\rget_cover_ar"
    "t\030\006 \001(\0132*.Remote.AudioCollectionRequest."
    "GetCoverArt\032.\n\016BatchParameter\022\016\n\006offset\030"
    "\001 \002(\r\022\014\n\004size\030\002 \002(\r\032V\n\014GetGenreList\022F\n\017b"
    "atch_parameter\030\001 \002(\0132-.Remote.AudioColle"
    "ctionRequest.BatchParameter\032i\n\rGetArtist"
    "List\022F\n\017batch_parameter\030\001 \002(\0132-.Remote.A"
    "udioCollectionRequest.BatchParameter\022\020\n\010"
    "genre_id\030\002 \003(\004\032\201\001\n\016GetReleaseList\022F\n\017bat"
    "ch_parameter\030\001 \002(\0132-.Remote.AudioCollect"
    "ionRequest.BatchParameter\022\021\n\tartist_id\030\002"
    " \003(\004\022\024\n\014filter_genre\030\003 \003(\004\032\217\001\n\014GetTrackL"
    "ist\022F\n\017batch_parameter\030\001 \002(\0132-.Remote.Au"
    "dioCollectionRequest.BatchParameter\022\021\n\ta"
    "rtist_id\030\002 \003(\004\022\022\n\nrelease_id\030\003 \003(\004\022\020\n\010ge"
    "nre_id\030\004 \003(\004\032\260\001\n\013GetCoverArt\022=\n\004type\030\001 \002"
    "(\0162/.Remote.AudioCollectionRequest.GetCo"
    "verArt.Type\022\022\n\nrelease_id\030\002 \001(\004\022\020\n\010track"
    "_id\030\003 \001(\004\"<\n\004Type\022\032\n\026TypeGetCoverArtRele"
    "ase\020\001\022\030\n\024TypeGetCoverArtTrack\020\002\"\213\001\n\004Type"
    "\022\023\n\017TypeGetRevision\020\001\022\024\n\020TypeGetGenreLis"
    "t\020\002\022\025\n\021TypeGetArtistList\020\003\022\026\n\022TypeGetRel"
    "easeList\020\004\022\024\n\020TypeGetTrackList\020\005\022\023\n\017Type"
    "GetCoverArt\020\006\"\345\n\n\027AudioCollectionRespons"
    "e\0222\n\004type\030\001 \001(\0162$.Remote.AudioCollection"
    "Response.Type\022\034\n\005error\030\002 \001(\0132\r.Remote.Er"
    "ror\022:\n\010revision\030\003 \001(\0132(.Remote.AudioColl"
    "ectionResponse.Revision\022=\n\ngenre_list\030\004 "
    "\001(\0132).Remote.AudioCollectionResponse.Gen"
    "reList\022\?\n\013artist_list\030\005 \001(\0132*.Remote.Aud"
    "ioCollectionResponse.ArtistList\022A\n\014relea"
    "se_list\030\006 \001(\0132+.Remote.AudioCollectionRe"
    "sponse.ReleaseList\022=\n\ntrack_list\030\007 \001(\0132)"
    ".Remote.AudioCollectionResponse.TrackLis"
    "t\022;\n\tcover_art\030\010 \003(\0132(.Remote.AudioColle"
    "ctionResponse.CoverArt\032\027\n\010Revision\022\013\n\003re"
    "v\030\001 \002(\004\032B\n\tGenreList\0225\n\006genres\030\002 \003(\0132%.R"
    "emote.AudioCollectionResponse.Genre\032E\n\nA"
    "rtistList\0227\n\007artists\030\002 \003(\0132&.Remote.Audi"
    "oCollectionResponse.Artist\032H\n\013ReleaseLis"
    "t\0229\n\010releases\030\002 \003(\0132\'.Remote.AudioCollec"
    "tionResponse.Release\032B\n\tTrackList\0225\n\006tra"
    "cks\030\002 \003(\0132%.Remote.AudioCollectionRespon"
    "se.Track\032+\n\010CoverArt\022\021\n\tmime_type\030\001 \001(\t\022"
    "\014\n\004data\030\002 \002(\014\032!\n\005Genre\022\n\n\002id\030\001 \002(\004\022\014\n\004na"
    "me\030\002 \002(\t\0327\n\006Artist\022\n\n\002id\030\001 \002(\004\022\014\n\004name\030\002"
    " \002(\t\022\023\n\013nb_releases\030\003 \002(\r\032c\n\007Release\022\n\n\002"
    "id\030\001 \002(\004\022\014\n\004name\030\002 \002(\t\022\021\n\tnb_tracks\030\003 \002("
    "\r\022\025\n\rduration_secs\030\004 \002(\r\022\024\n\014release_date"
    "\030\005 \001(\t\032\321\001\n\005Track\022\n\n\002id\030\001 \002(\004\022\021\n\tartist_i"
    "d\030\002 \002(\004\022\022\n\nrelease_id\030\003 \002(\004\022\020\n\010genre_id\030"
    "\004 \003(\004\022\023\n\013disc_number\030\005 \001(\r\022\024\n\014track_numb"
    "er\030\006 \001(\r\022\014\n\004name\030\007 \002(\t\022\025\n\rduration_secs\030"
    "\010 \002(\r\022\024\n\014release_date\030\t \001(\t\022\035\n\025original_"
    "release_date\030\n \001(\t\"\210\001\n\004Type\022\r\n\tTypeError"
    "\020\001\022\020\n\014TypeRevision\020\002\022\021\n\rTypeGenreList\020\003\022"
    "\022\n\016TypeArtistList\020\004\022\023\n\017TypeReleaseList\020\005"
    "\022\021\n\rTypeTrackList\020\006\022\020\n\014TypeCoverArt\020\007", 2677);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "collection.proto", &protobuf_RegisterTypes);
  AudioCollectionRequest::default_instance_ = new AudioCollectionRequest();
  AudioCollectionRequest_BatchParameter::default_instance_ = new AudioCollectionRequest_BatchParameter();
  AudioCollectionRequest_GetGenreList::default_instance_ = new AudioCollectionRequest_GetGenreList();
  AudioCollectionRequest_GetArtistList::default_instance_ = new AudioCollectionRequest_GetArtistList();
  AudioCollectionRequest_GetReleaseList::default_instance_ = new AudioCollectionRequest_GetReleaseList();
  AudioCollectionRequest_GetTrackList::default_instance_ = new AudioCollectionRequest_GetTrackList();
  AudioCollectionRequest_GetCoverArt::default_instance_ = new AudioCollectionRequest_GetCoverArt();
  AudioCollectionResponse::default_instance_ = new AudioCollectionResponse();
  AudioCollectionResponse_Revision::default_instance_ = new AudioCollectionResponse_Revision();
  AudioCollectionResponse_GenreList::default_instance_ = new AudioCollectionResponse_GenreList();
  AudioCollectionResponse_ArtistList::default_instance_ = new AudioCollectionResponse_ArtistList();
  AudioCollectionResponse_ReleaseList::default_instance_ = new AudioCollectionResponse_ReleaseList();
  AudioCollectionResponse_TrackList::default_instance_ = new AudioCollectionResponse_TrackList();
  AudioCollectionResponse_CoverArt::default_instance_ = new AudioCollectionResponse_CoverArt();
  AudioCollectionResponse_Genre::default_instance_ = new AudioCollectionResponse_Genre();
  AudioCollectionResponse_Artist::default_instance_ = new AudioCollectionResponse_Artist();
  AudioCollectionResponse_Release::default_instance_ = new AudioCollectionResponse_Release();
  AudioCollectionResponse_Track::default_instance_ = new AudioCollectionResponse_Track();
  AudioCollectionRequest::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_BatchParameter::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetGenreList::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetArtistList::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetReleaseList::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetTrackList::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetCoverArt::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Revision::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_GenreList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_ArtistList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_ReleaseList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_TrackList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_CoverArt::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Genre::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Artist::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Release::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Track::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_collection_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_collection_2eproto {
  StaticDescriptorInitializer_collection_2eproto() {
    protobuf_AddDesc_collection_2eproto();
  }
} static_descriptor_initializer_collection_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_Type_descriptor_;
}
bool AudioCollectionRequest_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetRevision;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetGenreList;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetArtistList;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetReleaseList;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetTrackList;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetCoverArt;
const AudioCollectionRequest_Type AudioCollectionRequest::Type_MIN;
const AudioCollectionRequest_Type AudioCollectionRequest::Type_MAX;
const int AudioCollectionRequest::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AudioCollectionRequest_BatchParameter::kOffsetFieldNumber;
const int AudioCollectionRequest_BatchParameter::kSizeFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_BatchParameter::AudioCollectionRequest_BatchParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_BatchParameter::InitAsDefaultInstance() {
}

AudioCollectionRequest_BatchParameter::AudioCollectionRequest_BatchParameter(const AudioCollectionRequest_BatchParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_BatchParameter::SharedCtor() {
  _cached_size_ = 0;
  offset_ = 0u;
  size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_BatchParameter::~AudioCollectionRequest_BatchParameter() {
  SharedDtor();
}

void AudioCollectionRequest_BatchParameter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionRequest_BatchParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_BatchParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_BatchParameter_descriptor_;
}

const AudioCollectionRequest_BatchParameter& AudioCollectionRequest_BatchParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_BatchParameter* AudioCollectionRequest_BatchParameter::default_instance_ = NULL;

AudioCollectionRequest_BatchParameter* AudioCollectionRequest_BatchParameter::New() const {
  return new AudioCollectionRequest_BatchParameter;
}

void AudioCollectionRequest_BatchParameter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    offset_ = 0u;
    size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_BatchParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 offset = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }

      // required uint32 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_BatchParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 offset = 1;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->offset(), output);
  }

  // required uint32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_BatchParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 offset = 1;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->offset(), target);
  }

  // required uint32 size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_BatchParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // required uint32 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_BatchParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_BatchParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_BatchParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_BatchParameter::MergeFrom(const AudioCollectionRequest_BatchParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_BatchParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_BatchParameter::CopyFrom(const AudioCollectionRequest_BatchParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_BatchParameter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AudioCollectionRequest_BatchParameter::Swap(AudioCollectionRequest_BatchParameter* other) {
  if (other != this) {
    std::swap(offset_, other->offset_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_BatchParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_BatchParameter_descriptor_;
  metadata.reflection = AudioCollectionRequest_BatchParameter_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetGenreList::kBatchParameterFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetGenreList::AudioCollectionRequest_GetGenreList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetGenreList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetGenreList::AudioCollectionRequest_GetGenreList(const AudioCollectionRequest_GetGenreList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetGenreList::SharedCtor() {
  _cached_size_ = 0;
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetGenreList::~AudioCollectionRequest_GetGenreList() {
  SharedDtor();
}

void AudioCollectionRequest_GetGenreList::SharedDtor() {
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetGenreList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetGenreList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetGenreList_descriptor_;
}

const AudioCollectionRequest_GetGenreList& AudioCollectionRequest_GetGenreList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetGenreList* AudioCollectionRequest_GetGenreList::default_instance_ = NULL;

AudioCollectionRequest_GetGenreList* AudioCollectionRequest_GetGenreList::New() const {
  return new AudioCollectionRequest_GetGenreList;
}

void AudioCollectionRequest_GetGenreList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetGenreList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetGenreList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->batch_parameter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetGenreList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->batch_parameter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetGenreList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetGenreList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetGenreList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetGenreList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetGenreList::MergeFrom(const AudioCollectionRequest_GetGenreList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetGenreList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetGenreList::CopyFrom(const AudioCollectionRequest_GetGenreList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetGenreList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetGenreList::Swap(AudioCollectionRequest_GetGenreList* other) {
  if (other != this) {
    std::swap(batch_parameter_, other->batch_parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetGenreList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetGenreList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetGenreList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetArtistList::kBatchParameterFieldNumber;
const int AudioCollectionRequest_GetArtistList::kGenreIdFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetArtistList::AudioCollectionRequest_GetArtistList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetArtistList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetArtistList::AudioCollectionRequest_GetArtistList(const AudioCollectionRequest_GetArtistList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetArtistList::SharedCtor() {
  _cached_size_ = 0;
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetArtistList::~AudioCollectionRequest_GetArtistList() {
  SharedDtor();
}

void AudioCollectionRequest_GetArtistList::SharedDtor() {
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetArtistList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetArtistList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetArtistList_descriptor_;
}

const AudioCollectionRequest_GetArtistList& AudioCollectionRequest_GetArtistList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetArtistList* AudioCollectionRequest_GetArtistList::default_instance_ = NULL;

AudioCollectionRequest_GetArtistList* AudioCollectionRequest_GetArtistList::New() const {
  return new AudioCollectionRequest_GetArtistList;
}

void AudioCollectionRequest_GetArtistList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  genre_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetArtistList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_genre_id;
        break;
      }

      // repeated uint64 genre_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_genre_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_genre_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_genre_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_genre_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetArtistList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->batch_parameter(), output);
  }

  // repeated uint64 genre_id = 2;
  for (int i = 0; i < this->genre_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->genre_id(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetArtistList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->batch_parameter(), target);
  }

  // repeated uint64 genre_id = 2;
  for (int i = 0; i < this->genre_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(2, this->genre_id(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetArtistList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  // repeated uint64 genre_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->genre_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->genre_id(i));
    }
    total_size += 1 * this->genre_id_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetArtistList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetArtistList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetArtistList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetArtistList::MergeFrom(const AudioCollectionRequest_GetArtistList& from) {
  GOOGLE_CHECK_NE(&from, this);
  genre_id_.MergeFrom(from.genre_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetArtistList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetArtistList::CopyFrom(const AudioCollectionRequest_GetArtistList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetArtistList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetArtistList::Swap(AudioCollectionRequest_GetArtistList* other) {
  if (other != this) {
    std::swap(batch_parameter_, other->batch_parameter_);
    genre_id_.Swap(&other->genre_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetArtistList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetArtistList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetArtistList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetReleaseList::kBatchParameterFieldNumber;
const int AudioCollectionRequest_GetReleaseList::kArtistIdFieldNumber;
const int AudioCollectionRequest_GetReleaseList::kFilterGenreFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetReleaseList::AudioCollectionRequest_GetReleaseList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetReleaseList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetReleaseList::AudioCollectionRequest_GetReleaseList(const AudioCollectionRequest_GetReleaseList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetReleaseList::SharedCtor() {
  _cached_size_ = 0;
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetReleaseList::~AudioCollectionRequest_GetReleaseList() {
  SharedDtor();
}

void AudioCollectionRequest_GetReleaseList::SharedDtor() {
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetReleaseList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetReleaseList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetReleaseList_descriptor_;
}

const AudioCollectionRequest_GetReleaseList& AudioCollectionRequest_GetReleaseList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetReleaseList* AudioCollectionRequest_GetReleaseList::default_instance_ = NULL;

AudioCollectionRequest_GetReleaseList* AudioCollectionRequest_GetReleaseList::New() const {
  return new AudioCollectionRequest_GetReleaseList;
}

void AudioCollectionRequest_GetReleaseList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  artist_id_.Clear();
  filter_genre_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetReleaseList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_artist_id;
        break;
      }

      // repeated uint64 artist_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_artist_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_artist_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_artist_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_artist_id;
        if (input->ExpectTag(24)) goto parse_filter_genre;
        break;
      }

      // repeated uint64 filter_genre = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_genre:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_filter_genre())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_filter_genre())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_filter_genre;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetReleaseList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->batch_parameter(), output);
  }

  // repeated uint64 artist_id = 2;
  for (int i = 0; i < this->artist_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->artist_id(i), output);
  }

  // repeated uint64 filter_genre = 3;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->filter_genre(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetReleaseList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->batch_parameter(), target);
  }

  // repeated uint64 artist_id = 2;
  for (int i = 0; i < this->artist_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(2, this->artist_id(i), target);
  }

  // repeated uint64 filter_genre = 3;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(3, this->filter_genre(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetReleaseList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  // repeated uint64 artist_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->artist_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->artist_id(i));
    }
    total_size += 1 * this->artist_id_size() + data_size;
  }

  // repeated uint64 filter_genre = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->filter_genre_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->filter_genre(i));
    }
    total_size += 1 * this->filter_genre_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetReleaseList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetReleaseList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetReleaseList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetReleaseList::MergeFrom(const AudioCollectionRequest_GetReleaseList& from) {
  GOOGLE_CHECK_NE(&from, this);
  artist_id_.MergeFrom(from.artist_id_);
  filter_genre_.MergeFrom(from.filter_genre_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetReleaseList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetReleaseList::CopyFrom(const AudioCollectionRequest_GetReleaseList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetReleaseList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetReleaseList::Swap(AudioCollectionRequest_GetReleaseList* other) {
  if (other != this) {
    std::swap(batch_parameter_, other->batch_parameter_);
    artist_id_.Swap(&other->artist_id_);
    filter_genre_.Swap(&other->filter_genre_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetReleaseList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetReleaseList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetReleaseList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetTrackList::kBatchParameterFieldNumber;
const int AudioCollectionRequest_GetTrackList::kArtistIdFieldNumber;
const int AudioCollectionRequest_GetTrackList::kReleaseIdFieldNumber;
const int AudioCollectionRequest_GetTrackList::kGenreIdFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetTrackList::AudioCollectionRequest_GetTrackList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetTrackList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetTrackList::AudioCollectionRequest_GetTrackList(const AudioCollectionRequest_GetTrackList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetTrackList::SharedCtor() {
  _cached_size_ = 0;
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetTrackList::~AudioCollectionRequest_GetTrackList() {
  SharedDtor();
}

void AudioCollectionRequest_GetTrackList::SharedDtor() {
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetTrackList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetTrackList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetTrackList_descriptor_;
}

const AudioCollectionRequest_GetTrackList& AudioCollectionRequest_GetTrackList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetTrackList* AudioCollectionRequest_GetTrackList::default_instance_ = NULL;

AudioCollectionRequest_GetTrackList* AudioCollectionRequest_GetTrackList::New() const {
  return new AudioCollectionRequest_GetTrackList;
}

void AudioCollectionRequest_GetTrackList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  artist_id_.Clear();
  release_id_.Clear();
  genre_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetTrackList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_artist_id;
        break;
      }

      // repeated uint64 artist_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_artist_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_artist_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_artist_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_artist_id;
        if (input->ExpectTag(24)) goto parse_release_id;
        break;
      }

      // repeated uint64 release_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_release_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 24, input, this->mutable_release_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_release_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_release_id;
        if (input->ExpectTag(32)) goto parse_genre_id;
        break;
      }

      // repeated uint64 genre_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_genre_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 32, input, this->mutable_genre_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_genre_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_genre_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetTrackList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->batch_parameter(), output);
  }

  // repeated uint64 artist_id = 2;
  for (int i = 0; i < this->artist_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->artist_id(i), output);
  }

  // repeated uint64 release_id = 3;
  for (int i = 0; i < this->release_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      3, this->release_id(i), output);
  }

  // repeated uint64 genre_id = 4;
  for (int i = 0; i < this->genre_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      4, this->genre_id(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetTrackList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->batch_parameter(), target);
  }

  // repeated uint64 artist_id = 2;
  for (int i = 0; i < this->artist_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(2, this->artist_id(i), target);
  }

  // repeated uint64 release_id = 3;
  for (int i = 0; i < this->release_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(3, this->release_id(i), target);
  }

  // repeated uint64 genre_id = 4;
  for (int i = 0; i < this->genre_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(4, this->genre_id(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetTrackList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  // repeated uint64 artist_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->artist_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->artist_id(i));
    }
    total_size += 1 * this->artist_id_size() + data_size;
  }

  // repeated uint64 release_id = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->release_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->release_id(i));
    }
    total_size += 1 * this->release_id_size() + data_size;
  }

  // repeated uint64 genre_id = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->genre_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->genre_id(i));
    }
    total_size += 1 * this->genre_id_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetTrackList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetTrackList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetTrackList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetTrackList::MergeFrom(const AudioCollectionRequest_GetTrackList& from) {
  GOOGLE_CHECK_NE(&from, this);
  artist_id_.MergeFrom(from.artist_id_);
  release_id_.MergeFrom(from.release_id_);
  genre_id_.MergeFrom(from.genre_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetTrackList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetTrackList::CopyFrom(const AudioCollectionRequest_GetTrackList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetTrackList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetTrackList::Swap(AudioCollectionRequest_GetTrackList* other) {
  if (other != this) {
    std::swap(batch_parameter_, other->batch_parameter_);
    artist_id_.Swap(&other->artist_id_);
    release_id_.Swap(&other->release_id_);
    genre_id_.Swap(&other->genre_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetTrackList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetTrackList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetTrackList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_GetCoverArt_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetCoverArt_Type_descriptor_;
}
bool AudioCollectionRequest_GetCoverArt_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AudioCollectionRequest_GetCoverArt_Type AudioCollectionRequest_GetCoverArt::TypeGetCoverArtRelease;
const AudioCollectionRequest_GetCoverArt_Type AudioCollectionRequest_GetCoverArt::TypeGetCoverArtTrack;
const AudioCollectionRequest_GetCoverArt_Type AudioCollectionRequest_GetCoverArt::Type_MIN;
const AudioCollectionRequest_GetCoverArt_Type AudioCollectionRequest_GetCoverArt::Type_MAX;
const int AudioCollectionRequest_GetCoverArt::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AudioCollectionRequest_GetCoverArt::kTypeFieldNumber;
const int AudioCollectionRequest_GetCoverArt::kReleaseIdFieldNumber;
const int AudioCollectionRequest_GetCoverArt::kTrackIdFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetCoverArt::AudioCollectionRequest_GetCoverArt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetCoverArt::InitAsDefaultInstance() {
}

AudioCollectionRequest_GetCoverArt::AudioCollectionRequest_GetCoverArt(const AudioCollectionRequest_GetCoverArt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetCoverArt::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  release_id_ = GOOGLE_ULONGLONG(0);
  track_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetCoverArt::~AudioCollectionRequest_GetCoverArt() {
  SharedDtor();
}

void AudioCollectionRequest_GetCoverArt::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionRequest_GetCoverArt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetCoverArt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetCoverArt_descriptor_;
}

const AudioCollectionRequest_GetCoverArt& AudioCollectionRequest_GetCoverArt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetCoverArt* AudioCollectionRequest_GetCoverArt::default_instance_ = NULL;

AudioCollectionRequest_GetCoverArt* AudioCollectionRequest_GetCoverArt::New() const {
  return new AudioCollectionRequest_GetCoverArt;
}

void AudioCollectionRequest_GetCoverArt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    release_id_ = GOOGLE_ULONGLONG(0);
    track_id_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetCoverArt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Remote.AudioCollectionRequest.GetCoverArt.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Remote::AudioCollectionRequest_GetCoverArt_Type_IsValid(value)) {
            set_type(static_cast< ::Remote::AudioCollectionRequest_GetCoverArt_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_release_id;
        break;
      }

      // optional uint64 release_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_release_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &release_id_)));
          set_has_release_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_track_id;
        break;
      }

      // optional uint64 track_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_track_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &track_id_)));
          set_has_track_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetCoverArt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Remote.AudioCollectionRequest.GetCoverArt.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint64 release_id = 2;
  if (has_release_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->release_id(), output);
  }

  // optional uint64 track_id = 3;
  if (has_track_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->track_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetCoverArt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Remote.AudioCollectionRequest.GetCoverArt.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional uint64 release_id = 2;
  if (has_release_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->release_id(), target);
  }

  // optional uint64 track_id = 3;
  if (has_track_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->track_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetCoverArt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Remote.AudioCollectionRequest.GetCoverArt.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 release_id = 2;
    if (has_release_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->release_id());
    }

    // optional uint64 track_id = 3;
    if (has_track_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->track_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetCoverArt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetCoverArt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetCoverArt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetCoverArt::MergeFrom(const AudioCollectionRequest_GetCoverArt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_release_id()) {
      set_release_id(from.release_id());
    }
    if (from.has_track_id()) {
      set_track_id(from.track_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetCoverArt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetCoverArt::CopyFrom(const AudioCollectionRequest_GetCoverArt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetCoverArt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AudioCollectionRequest_GetCoverArt::Swap(AudioCollectionRequest_GetCoverArt* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(release_id_, other->release_id_);
    std::swap(track_id_, other->track_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetCoverArt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetCoverArt_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetCoverArt_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest::kTypeFieldNumber;
const int AudioCollectionRequest::kGetGenresFieldNumber;
const int AudioCollectionRequest::kGetArtistsFieldNumber;
const int AudioCollectionRequest::kGetReleasesFieldNumber;
const int AudioCollectionRequest::kGetTracksFieldNumber;
const int AudioCollectionRequest::kGetCoverArtFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest::AudioCollectionRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest::InitAsDefaultInstance() {
  get_genres_ = const_cast< ::Remote::AudioCollectionRequest_GetGenreList*>(&::Remote::AudioCollectionRequest_GetGenreList::default_instance());
  get_artists_ = const_cast< ::Remote::AudioCollectionRequest_GetArtistList*>(&::Remote::AudioCollectionRequest_GetArtistList::default_instance());
  get_releases_ = const_cast< ::Remote::AudioCollectionRequest_GetReleaseList*>(&::Remote::AudioCollectionRequest_GetReleaseList::default_instance());
  get_tracks_ = const_cast< ::Remote::AudioCollectionRequest_GetTrackList*>(&::Remote::AudioCollectionRequest_GetTrackList::default_instance());
  get_cover_art_ = const_cast< ::Remote::AudioCollectionRequest_GetCoverArt*>(&::Remote::AudioCollectionRequest_GetCoverArt::default_instance());
}

AudioCollectionRequest::AudioCollectionRequest(const AudioCollectionRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  get_genres_ = NULL;
  get_artists_ = NULL;
  get_releases_ = NULL;
  get_tracks_ = NULL;
  get_cover_art_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest::~AudioCollectionRequest() {
  SharedDtor();
}

void AudioCollectionRequest::SharedDtor() {
  if (this != default_instance_) {
    delete get_genres_;
    delete get_artists_;
    delete get_releases_;
    delete get_tracks_;
    delete get_cover_art_;
  }
}

void AudioCollectionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_descriptor_;
}

const AudioCollectionRequest& AudioCollectionRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest* AudioCollectionRequest::default_instance_ = NULL;

AudioCollectionRequest* AudioCollectionRequest::New() const {
  return new AudioCollectionRequest;
}

void AudioCollectionRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_get_genres()) {
      if (get_genres_ != NULL) get_genres_->::Remote::AudioCollectionRequest_GetGenreList::Clear();
    }
    if (has_get_artists()) {
      if (get_artists_ != NULL) get_artists_->::Remote::AudioCollectionRequest_GetArtistList::Clear();
    }
    if (has_get_releases()) {
      if (get_releases_ != NULL) get_releases_->::Remote::AudioCollectionRequest_GetReleaseList::Clear();
    }
    if (has_get_tracks()) {
      if (get_tracks_ != NULL) get_tracks_->::Remote::AudioCollectionRequest_GetTrackList::Clear();
    }
    if (has_get_cover_art()) {
      if (get_cover_art_ != NULL) get_cover_art_->::Remote::AudioCollectionRequest_GetCoverArt::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Remote.AudioCollectionRequest.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Remote::AudioCollectionRequest_Type_IsValid(value)) {
            set_type(static_cast< ::Remote::AudioCollectionRequest_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_get_genres;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_genres()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_artists;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_artists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_artists()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_get_releases;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_releases:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_releases()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_get_tracks;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_tracks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_tracks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_get_cover_art;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetCoverArt get_cover_art = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_cover_art:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_cover_art()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Remote.AudioCollectionRequest.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
  if (has_get_genres()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->get_genres(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
  if (has_get_artists()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_artists(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
  if (has_get_releases()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->get_releases(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
  if (has_get_tracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->get_tracks(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetCoverArt get_cover_art = 6;
  if (has_get_cover_art()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->get_cover_art(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Remote.AudioCollectionRequest.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
  if (has_get_genres()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->get_genres(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
  if (has_get_artists()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_artists(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
  if (has_get_releases()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->get_releases(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
  if (has_get_tracks()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->get_tracks(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetCoverArt get_cover_art = 6;
  if (has_get_cover_art()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->get_cover_art(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Remote.AudioCollectionRequest.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
    if (has_get_genres()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_genres());
    }

    // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
    if (has_get_artists()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_artists());
    }

    // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
    if (has_get_releases()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_releases());
    }

    // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
    if (has_get_tracks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_tracks());
    }

    // optional .Remote.AudioCollectionRequest.GetCoverArt get_cover_art = 6;
    if (has_get_cover_art()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_cover_art());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest::MergeFrom(const AudioCollectionRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_get_genres()) {
      mutable_get_genres()->::Remote::AudioCollectionRequest_GetGenreList::MergeFrom(from.get_genres());
    }
    if (from.has_get_artists()) {
      mutable_get_artists()->::Remote::AudioCollectionRequest_GetArtistList::MergeFrom(from.get_artists());
    }
    if (from.has_get_releases()) {
      mutable_get_releases()->::Remote::AudioCollectionRequest_GetReleaseList::MergeFrom(from.get_releases());
    }
    if (from.has_get_tracks()) {
      mutable_get_tracks()->::Remote::AudioCollectionRequest_GetTrackList::MergeFrom(from.get_tracks());
    }
    if (from.has_get_cover_art()) {
      mutable_get_cover_art()->::Remote::AudioCollectionRequest_GetCoverArt::MergeFrom(from.get_cover_art());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest::CopyFrom(const AudioCollectionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_get_genres()) {
    if (!this->get_genres().IsInitialized()) return false;
  }
  if (has_get_artists()) {
    if (!this->get_artists().IsInitialized()) return false;
  }
  if (has_get_releases()) {
    if (!this->get_releases().IsInitialized()) return false;
  }
  if (has_get_tracks()) {
    if (!this->get_tracks().IsInitialized()) return false;
  }
  if (has_get_cover_art()) {
    if (!this->get_cover_art().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest::Swap(AudioCollectionRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(get_genres_, other->get_genres_);
    std::swap(get_artists_, other->get_artists_);
    std::swap(get_releases_, other->get_releases_);
    std::swap(get_tracks_, other->get_tracks_);
    std::swap(get_cover_art_, other->get_cover_art_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_descriptor_;
  metadata.reflection = AudioCollectionRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* AudioCollectionResponse_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Type_descriptor_;
}
bool AudioCollectionResponse_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AudioCollectionResponse_Type AudioCollectionResponse::TypeError;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeRevision;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeGenreList;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeArtistList;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeReleaseList;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeTrackList;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeCoverArt;
const AudioCollectionResponse_Type AudioCollectionResponse::Type_MIN;
const AudioCollectionResponse_Type AudioCollectionResponse::Type_MAX;
const int AudioCollectionResponse::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AudioCollectionResponse_Revision::kRevFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Revision::AudioCollectionResponse_Revision()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Revision::InitAsDefaultInstance() {
}

AudioCollectionResponse_Revision::AudioCollectionResponse_Revision(const AudioCollectionResponse_Revision& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Revision::SharedCtor() {
  _cached_size_ = 0;
  rev_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Revision::~AudioCollectionResponse_Revision() {
  SharedDtor();
}

void AudioCollectionResponse_Revision::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Revision::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Revision::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Revision_descriptor_;
}

const AudioCollectionResponse_Revision& AudioCollectionResponse_Revision::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Revision* AudioCollectionResponse_Revision::default_instance_ = NULL;

AudioCollectionResponse_Revision* AudioCollectionResponse_Revision::New() const {
  return new AudioCollectionResponse_Revision;
}

void AudioCollectionResponse_Revision::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rev_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Revision::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 rev = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &rev_)));
          set_has_rev();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Revision::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 rev = 1;
  if (has_rev()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->rev(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Revision::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 rev = 1;
  if (has_rev()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->rev(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Revision::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 rev = 1;
    if (has_rev()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->rev());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Revision::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Revision* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Revision*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Revision::MergeFrom(const AudioCollectionResponse_Revision& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rev()) {
      set_rev(from.rev());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Revision::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Revision::CopyFrom(const AudioCollectionResponse_Revision& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Revision::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AudioCollectionResponse_Revision::Swap(AudioCollectionResponse_Revision* other) {
  if (other != this) {
    std::swap(rev_, other->rev_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Revision::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Revision_descriptor_;
  metadata.reflection = AudioCollectionResponse_Revision_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_GenreList::kGenresFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_GenreList::AudioCollectionResponse_GenreList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_GenreList::InitAsDefaultInstance() {
}

AudioCollectionResponse_GenreList::AudioCollectionResponse_GenreList(const AudioCollectionResponse_GenreList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_GenreList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_GenreList::~AudioCollectionResponse_GenreList() {
  SharedDtor();
}

void AudioCollectionResponse_GenreList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_GenreList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_GenreList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_GenreList_descriptor_;
}

const AudioCollectionResponse_GenreList& AudioCollectionResponse_GenreList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_GenreList* AudioCollectionResponse_GenreList::default_instance_ = NULL;

AudioCollectionResponse_GenreList* AudioCollectionResponse_GenreList::New() const {
  return new AudioCollectionResponse_GenreList;
}

void AudioCollectionResponse_GenreList::Clear() {
  genres_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_GenreList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_genres()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_genres;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_GenreList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
  for (int i = 0; i < this->genres_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->genres(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_GenreList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
  for (int i = 0; i < this->genres_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->genres(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_GenreList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
  total_size += 1 * this->genres_size();
  for (int i = 0; i < this->genres_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->genres(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_GenreList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_GenreList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_GenreList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_GenreList::MergeFrom(const AudioCollectionResponse_GenreList& from) {
  GOOGLE_CHECK_NE(&from, this);
  genres_.MergeFrom(from.genres_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_GenreList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_GenreList::CopyFrom(const AudioCollectionResponse_GenreList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_GenreList::IsInitialized() const {

  for (int i = 0; i < genres_size(); i++) {
    if (!this->genres(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_GenreList::Swap(AudioCollectionResponse_GenreList* other) {
  if (other != this) {
    genres_.Swap(&other->genres_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_GenreList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_GenreList_descriptor_;
  metadata.reflection = AudioCollectionResponse_GenreList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_ArtistList::kArtistsFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_ArtistList::AudioCollectionResponse_ArtistList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_ArtistList::InitAsDefaultInstance() {
}

AudioCollectionResponse_ArtistList::AudioCollectionResponse_ArtistList(const AudioCollectionResponse_ArtistList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_ArtistList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_ArtistList::~AudioCollectionResponse_ArtistList() {
  SharedDtor();
}

void AudioCollectionResponse_ArtistList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_ArtistList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_ArtistList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_ArtistList_descriptor_;
}

const AudioCollectionResponse_ArtistList& AudioCollectionResponse_ArtistList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_ArtistList* AudioCollectionResponse_ArtistList::default_instance_ = NULL;

AudioCollectionResponse_ArtistList* AudioCollectionResponse_ArtistList::New() const {
  return new AudioCollectionResponse_ArtistList;
}

void AudioCollectionResponse_ArtistList::Clear() {
  artists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_ArtistList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_artists()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artists;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_ArtistList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
  for (int i = 0; i < this->artists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->artists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_ArtistList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
  for (int i = 0; i < this->artists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->artists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_ArtistList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
  total_size += 1 * this->artists_size();
  for (int i = 0; i < this->artists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->artists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_ArtistList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_ArtistList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_ArtistList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_ArtistList::MergeFrom(const AudioCollectionResponse_ArtistList& from) {
  GOOGLE_CHECK_NE(&from, this);
  artists_.MergeFrom(from.artists_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_ArtistList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_ArtistList::CopyFrom(const AudioCollectionResponse_ArtistList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_ArtistList::IsInitialized() const {

  for (int i = 0; i < artists_size(); i++) {
    if (!this->artists(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_ArtistList::Swap(AudioCollectionResponse_ArtistList* other) {
  if (other != this) {
    artists_.Swap(&other->artists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_ArtistList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_ArtistList_descriptor_;
  metadata.reflection = AudioCollectionResponse_ArtistList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_ReleaseList::kReleasesFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_ReleaseList::AudioCollectionResponse_ReleaseList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_ReleaseList::InitAsDefaultInstance() {
}

AudioCollectionResponse_ReleaseList::AudioCollectionResponse_ReleaseList(const AudioCollectionResponse_ReleaseList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_ReleaseList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_ReleaseList::~AudioCollectionResponse_ReleaseList() {
  SharedDtor();
}

void AudioCollectionResponse_ReleaseList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_ReleaseList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_ReleaseList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_ReleaseList_descriptor_;
}

const AudioCollectionResponse_ReleaseList& AudioCollectionResponse_ReleaseList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_ReleaseList* AudioCollectionResponse_ReleaseList::default_instance_ = NULL;

AudioCollectionResponse_ReleaseList* AudioCollectionResponse_ReleaseList::New() const {
  return new AudioCollectionResponse_ReleaseList;
}

void AudioCollectionResponse_ReleaseList::Clear() {
  releases_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_ReleaseList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Release releases = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_releases:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_releases()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_releases;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_ReleaseList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Release releases = 2;
  for (int i = 0; i < this->releases_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->releases(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_ReleaseList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Release releases = 2;
  for (int i = 0; i < this->releases_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->releases(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_ReleaseList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Release releases = 2;
  total_size += 1 * this->releases_size();
  for (int i = 0; i < this->releases_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->releases(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_ReleaseList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_ReleaseList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_ReleaseList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_ReleaseList::MergeFrom(const AudioCollectionResponse_ReleaseList& from) {
  GOOGLE_CHECK_NE(&from, this);
  releases_.MergeFrom(from.releases_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_ReleaseList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_ReleaseList::CopyFrom(const AudioCollectionResponse_ReleaseList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_ReleaseList::IsInitialized() const {

  for (int i = 0; i < releases_size(); i++) {
    if (!this->releases(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_ReleaseList::Swap(AudioCollectionResponse_ReleaseList* other) {
  if (other != this) {
    releases_.Swap(&other->releases_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_ReleaseList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_ReleaseList_descriptor_;
  metadata.reflection = AudioCollectionResponse_ReleaseList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_TrackList::kTracksFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_TrackList::AudioCollectionResponse_TrackList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_TrackList::InitAsDefaultInstance() {
}

AudioCollectionResponse_TrackList::AudioCollectionResponse_TrackList(const AudioCollectionResponse_TrackList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_TrackList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_TrackList::~AudioCollectionResponse_TrackList() {
  SharedDtor();
}

void AudioCollectionResponse_TrackList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_TrackList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_TrackList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_TrackList_descriptor_;
}

const AudioCollectionResponse_TrackList& AudioCollectionResponse_TrackList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_TrackList* AudioCollectionResponse_TrackList::default_instance_ = NULL;

AudioCollectionResponse_TrackList* AudioCollectionResponse_TrackList::New() const {
  return new AudioCollectionResponse_TrackList;
}

void AudioCollectionResponse_TrackList::Clear() {
  tracks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_TrackList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tracks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tracks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tracks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_TrackList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
  for (int i = 0; i < this->tracks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tracks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_TrackList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
  for (int i = 0; i < this->tracks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tracks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_TrackList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
  total_size += 1 * this->tracks_size();
  for (int i = 0; i < this->tracks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tracks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_TrackList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_TrackList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_TrackList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_TrackList::MergeFrom(const AudioCollectionResponse_TrackList& from) {
  GOOGLE_CHECK_NE(&from, this);
  tracks_.MergeFrom(from.tracks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_TrackList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_TrackList::CopyFrom(const AudioCollectionResponse_TrackList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_TrackList::IsInitialized() const {

  for (int i = 0; i < tracks_size(); i++) {
    if (!this->tracks(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_TrackList::Swap(AudioCollectionResponse_TrackList* other) {
  if (other != this) {
    tracks_.Swap(&other->tracks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_TrackList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_TrackList_descriptor_;
  metadata.reflection = AudioCollectionResponse_TrackList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_CoverArt::kMimeTypeFieldNumber;
const int AudioCollectionResponse_CoverArt::kDataFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_CoverArt::AudioCollectionResponse_CoverArt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_CoverArt::InitAsDefaultInstance() {
}

AudioCollectionResponse_CoverArt::AudioCollectionResponse_CoverArt(const AudioCollectionResponse_CoverArt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_CoverArt::SharedCtor() {
  _cached_size_ = 0;
  mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_CoverArt::~AudioCollectionResponse_CoverArt() {
  SharedDtor();
}

void AudioCollectionResponse_CoverArt::SharedDtor() {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    delete mime_type_;
  }
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_CoverArt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_CoverArt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_CoverArt_descriptor_;
}

const AudioCollectionResponse_CoverArt& AudioCollectionResponse_CoverArt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_CoverArt* AudioCollectionResponse_CoverArt::default_instance_ = NULL;

AudioCollectionResponse_CoverArt* AudioCollectionResponse_CoverArt::New() const {
  return new AudioCollectionResponse_CoverArt;
}

void AudioCollectionResponse_CoverArt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mime_type()) {
      if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
        mime_type_->clear();
      }
    }
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_CoverArt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string mime_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mime_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mime_type().data(), this->mime_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_CoverArt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string mime_type = 1;
  if (has_mime_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mime_type().data(), this->mime_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mime_type(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_CoverArt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string mime_type = 1;
  if (has_mime_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mime_type().data(), this->mime_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mime_type(), target);
  }

  // required bytes data = 2;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_CoverArt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string mime_type = 1;
    if (has_mime_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mime_type());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_CoverArt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_CoverArt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_CoverArt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_CoverArt::MergeFrom(const AudioCollectionResponse_CoverArt& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mime_type()) {
      set_mime_type(from.mime_type());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_CoverArt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_CoverArt::CopyFrom(const AudioCollectionResponse_CoverArt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_CoverArt::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void AudioCollectionResponse_CoverArt::Swap(AudioCollectionResponse_CoverArt* other) {
  if (other != this) {
    std::swap(mime_type_, other->mime_type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_CoverArt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_CoverArt_descriptor_;
  metadata.reflection = AudioCollectionResponse_CoverArt_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Genre::kIdFieldNumber;
const int AudioCollectionResponse_Genre::kNameFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Genre::AudioCollectionResponse_Genre()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Genre::InitAsDefaultInstance() {
}

AudioCollectionResponse_Genre::AudioCollectionResponse_Genre(const AudioCollectionResponse_Genre& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Genre::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Genre::~AudioCollectionResponse_Genre() {
  SharedDtor();
}

void AudioCollectionResponse_Genre::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Genre::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Genre::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Genre_descriptor_;
}

const AudioCollectionResponse_Genre& AudioCollectionResponse_Genre::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Genre* AudioCollectionResponse_Genre::default_instance_ = NULL;

AudioCollectionResponse_Genre* AudioCollectionResponse_Genre::New() const {
  return new AudioCollectionResponse_Genre;
}

void AudioCollectionResponse_Genre::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Genre::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Genre::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Genre::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->id(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Genre::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Genre::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Genre* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Genre*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Genre::MergeFrom(const AudioCollectionResponse_Genre& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Genre::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Genre::CopyFrom(const AudioCollectionResponse_Genre& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Genre::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AudioCollectionResponse_Genre::Swap(AudioCollectionResponse_Genre* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Genre::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Genre_descriptor_;
  metadata.reflection = AudioCollectionResponse_Genre_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Artist::kIdFieldNumber;
const int AudioCollectionResponse_Artist::kNameFieldNumber;
const int AudioCollectionResponse_Artist::kNbReleasesFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Artist::AudioCollectionResponse_Artist()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Artist::InitAsDefaultInstance() {
}

AudioCollectionResponse_Artist::AudioCollectionResponse_Artist(const AudioCollectionResponse_Artist& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Artist::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nb_releases_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Artist::~AudioCollectionResponse_Artist() {
  SharedDtor();
}

void AudioCollectionResponse_Artist::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Artist::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Artist::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Artist_descriptor_;
}

const AudioCollectionResponse_Artist& AudioCollectionResponse_Artist::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Artist* AudioCollectionResponse_Artist::default_instance_ = NULL;

AudioCollectionResponse_Artist* AudioCollectionResponse_Artist::New() const {
  return new AudioCollectionResponse_Artist;
}

void AudioCollectionResponse_Artist::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    nb_releases_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Artist::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nb_releases;
        break;
      }

      // required uint32 nb_releases = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nb_releases:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nb_releases_)));
          set_has_nb_releases();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Artist::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // required uint32 nb_releases = 3;
  if (has_nb_releases()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->nb_releases(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Artist::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->id(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // required uint32 nb_releases = 3;
  if (has_nb_releases()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->nb_releases(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Artist::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 nb_releases = 3;
    if (has_nb_releases()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nb_releases());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Artist::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Artist* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Artist*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Artist::MergeFrom(const AudioCollectionResponse_Artist& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_nb_releases()) {
      set_nb_releases(from.nb_releases());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Artist::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Artist::CopyFrom(const AudioCollectionResponse_Artist& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Artist::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AudioCollectionResponse_Artist::Swap(AudioCollectionResponse_Artist* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(nb_releases_, other->nb_releases_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Artist::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Artist_descriptor_;
  metadata.reflection = AudioCollectionResponse_Artist_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Release::kIdFieldNumber;
const int AudioCollectionResponse_Release::kNameFieldNumber;
const int AudioCollectionResponse_Release::kNbTracksFieldNumber;
const int AudioCollectionResponse_Release::kDurationSecsFieldNumber;
const int AudioCollectionResponse_Release::kReleaseDateFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Release::AudioCollectionResponse_Release()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Release::InitAsDefaultInstance() {
}

AudioCollectionResponse_Release::AudioCollectionResponse_Release(const AudioCollectionResponse_Release& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Release::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nb_tracks_ = 0u;
  duration_secs_ = 0u;
  release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Release::~AudioCollectionResponse_Release() {
  SharedDtor();
}

void AudioCollectionResponse_Release::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete release_date_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Release::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Release::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Release_descriptor_;
}

const AudioCollectionResponse_Release& AudioCollectionResponse_Release::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Release* AudioCollectionResponse_Release::default_instance_ = NULL;

AudioCollectionResponse_Release* AudioCollectionResponse_Release::New() const {
  return new AudioCollectionResponse_Release;
}

void AudioCollectionResponse_Release::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    nb_tracks_ = 0u;
    duration_secs_ = 0u;
    if (has_release_date()) {
      if (release_date_ != &::google::protobuf::internal::kEmptyString) {
        release_date_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Release::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nb_tracks;
        break;
      }

      // required uint32 nb_tracks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nb_tracks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nb_tracks_)));
          set_has_nb_tracks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_duration_secs;
        break;
      }

      // required uint32 duration_secs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_secs_)));
          set_has_duration_secs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_release_date;
        break;
      }

      // optional string release_date = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_release_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release_date().data(), this->release_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Release::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // required uint32 nb_tracks = 3;
  if (has_nb_tracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->nb_tracks(), output);
  }

  // required uint32 duration_secs = 4;
  if (has_duration_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->duration_secs(), output);
  }

  // optional string release_date = 5;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->release_date(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Release::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->id(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // required uint32 nb_tracks = 3;
  if (has_nb_tracks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->nb_tracks(), target);
  }

  // required uint32 duration_secs = 4;
  if (has_duration_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->duration_secs(), target);
  }

  // optional string release_date = 5;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->release_date(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Release::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 nb_tracks = 3;
    if (has_nb_tracks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nb_tracks());
    }

    // required uint32 duration_secs = 4;
    if (has_duration_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration_secs());
    }

    // optional string release_date = 5;
    if (has_release_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->release_date());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Release::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Release* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Release*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Release::MergeFrom(const AudioCollectionResponse_Release& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_nb_tracks()) {
      set_nb_tracks(from.nb_tracks());
    }
    if (from.has_duration_secs()) {
      set_duration_secs(from.duration_secs());
    }
    if (from.has_release_date()) {
      set_release_date(from.release_date());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Release::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Release::CopyFrom(const AudioCollectionResponse_Release& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Release::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void AudioCollectionResponse_Release::Swap(AudioCollectionResponse_Release* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(nb_tracks_, other->nb_tracks_);
    std::swap(duration_secs_, other->duration_secs_);
    std::swap(release_date_, other->release_date_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Release::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Release_descriptor_;
  metadata.reflection = AudioCollectionResponse_Release_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Track::kIdFieldNumber;
const int AudioCollectionResponse_Track::kArtistIdFieldNumber;
const int AudioCollectionResponse_Track::kReleaseIdFieldNumber;
const int AudioCollectionResponse_Track::kGenreIdFieldNumber;
const int AudioCollectionResponse_Track::kDiscNumberFieldNumber;
const int AudioCollectionResponse_Track::kTrackNumberFieldNumber;
const int AudioCollectionResponse_Track::kNameFieldNumber;
const int AudioCollectionResponse_Track::kDurationSecsFieldNumber;
const int AudioCollectionResponse_Track::kReleaseDateFieldNumber;
const int AudioCollectionResponse_Track::kOriginalReleaseDateFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Track::AudioCollectionResponse_Track()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Track::InitAsDefaultInstance() {
}

AudioCollectionResponse_Track::AudioCollectionResponse_Track(const AudioCollectionResponse_Track& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Track::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  artist_id_ = GOOGLE_ULONGLONG(0);
  release_id_ = GOOGLE_ULONGLONG(0);
  disc_number_ = 0u;
  track_number_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  duration_secs_ = 0u;
  release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  original_release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Track::~AudioCollectionResponse_Track() {
  SharedDtor();
}

void AudioCollectionResponse_Track::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete release_date_;
  }
  if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete original_release_date_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Track::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Track::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Track_descriptor_;
}

const AudioCollectionResponse_Track& AudioCollectionResponse_Track::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Track* AudioCollectionResponse_Track::default_instance_ = NULL;

AudioCollectionResponse_Track* AudioCollectionResponse_Track::New() const {
  return new AudioCollectionResponse_Track;
}

void AudioCollectionResponse_Track::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_ULONGLONG(0);
    artist_id_ = GOOGLE_ULONGLONG(0);
    release_id_ = GOOGLE_ULONGLONG(0);
    disc_number_ = 0u;
    track_number_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    duration_secs_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_release_date()) {
      if (release_date_ != &::google::protobuf::internal::kEmptyString) {
        release_date_->clear();
      }
    }
    if (has_original_release_date()) {
      if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
        original_release_date_->clear();
      }
    }
  }
  genre_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Track::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_artist_id;
        break;
      }

      // required uint64 artist_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_artist_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &artist_id_)));
          set_has_artist_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_release_id;
        break;
      }

      // required uint64 release_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_release_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &release_id_)));
          set_has_release_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_genre_id;
        break;
      }

      // repeated uint64 genre_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_genre_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 32, input, this->mutable_genre_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_genre_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_genre_id;
        if (input->ExpectTag(40)) goto parse_disc_number;
        break;
      }

      // optional uint32 disc_number = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_disc_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &disc_number_)));
          set_has_disc_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_track_number;
        break;
      }

      // optional uint32 track_number = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_track_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &track_number_)));
          set_has_track_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_name;
        break;
      }

      // required string name = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_duration_secs;
        break;
      }

      // required uint32 duration_secs = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_secs_)));
          set_has_duration_secs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_release_date;
        break;
      }

      // optional string release_date = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_release_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release_date().data(), this->release_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_original_release_date;
        break;
      }

      // optional string original_release_date = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_original_release_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_original_release_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->original_release_date().data(), this->original_release_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Track::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // required uint64 artist_id = 2;
  if (has_artist_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->artist_id(), output);
  }

  // required uint64 release_id = 3;
  if (has_release_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->release_id(), output);
  }

  // repeated uint64 genre_id = 4;
  for (int i = 0; i < this->genre_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      4, this->genre_id(i), output);
  }

  // optional uint32 disc_number = 5;
  if (has_disc_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->disc_number(), output);
  }

  // optional uint32 track_number = 6;
  if (has_track_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->track_number(), output);
  }

  // required string name = 7;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->name(), output);
  }

  // required uint32 duration_secs = 8;
  if (has_duration_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->duration_secs(), output);
  }

  // optional string release_date = 9;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->release_date(), output);
  }

  // optional string original_release_date = 10;
  if (has_original_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->original_release_date().data(), this->original_release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->original_release_date(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Track::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->id(), target);
  }

  // required uint64 artist_id = 2;
  if (has_artist_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->artist_id(), target);
  }

  // required uint64 release_id = 3;
  if (has_release_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->release_id(), target);
  }

  // repeated uint64 genre_id = 4;
  for (int i = 0; i < this->genre_id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(4, this->genre_id(i), target);
  }

  // optional uint32 disc_number = 5;
  if (has_disc_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->disc_number(), target);
  }

  // optional uint32 track_number = 6;
  if (has_track_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->track_number(), target);
  }

  // required string name = 7;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->name(), target);
  }

  // required uint32 duration_secs = 8;
  if (has_duration_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->duration_secs(), target);
  }

  // optional string release_date = 9;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->release_date(), target);
  }

  // optional string original_release_date = 10;
  if (has_original_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->original_release_date().data(), this->original_release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->original_release_date(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Track::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // required uint64 artist_id = 2;
    if (has_artist_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->artist_id());
    }

    // required uint64 release_id = 3;
    if (has_release_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->release_id());
    }

    // optional uint32 disc_number = 5;
    if (has_disc_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->disc_number());
    }

    // optional uint32 track_number = 6;
    if (has_track_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->track_number());
    }

    // required string name = 7;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 duration_secs = 8;
    if (has_duration_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration_secs());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string release_date = 9;
    if (has_release_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->release_date());
    }

    // optional string original_release_date = 10;
    if (has_original_release_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->original_release_date());
    }

  }
  // repeated uint64 genre_id = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->genre_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->genre_id(i));
    }
    total_size += 1 * this->genre_id_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Track::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Track* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Track*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Track::MergeFrom(const AudioCollectionResponse_Track& from) {
  GOOGLE_CHECK_NE(&from, this);
  genre_id_.MergeFrom(from.genre_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_artist_id()) {
      set_artist_id(from.artist_id());
    }
    if (from.has_release_id()) {
      set_release_id(from.release_id());
    }
    if (from.has_disc_number()) {
      set_disc_number(from.disc_number());
    }
    if (from.has_track_number()) {
      set_track_number(from.track_number());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_duration_secs()) {
      set_duration_secs(from.duration_secs());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_release_date()) {
      set_release_date(from.release_date());
    }
    if (from.has_original_release_date()) {
      set_original_release_date(from.original_release_date());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Track::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Track::CopyFrom(const AudioCollectionResponse_Track& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Track::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000c7) != 0x000000c7) return false;

  return true;
}

void AudioCollectionResponse_Track::Swap(AudioCollectionResponse_Track* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(artist_id_, other->artist_id_);
    std::swap(release_id_, other->release_id_);
    genre_id_.Swap(&other->genre_id_);
    std::swap(disc_number_, other->disc_number_);
    std::swap(track_number_, other->track_number_);
    std::swap(name_, other->name_);
    std::swap(duration_secs_, other->duration_secs_);
    std::swap(release_date_, other->release_date_);
    std::swap(original_release_date_, other->original_release_date_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Track::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Track_descriptor_;
  metadata.reflection = AudioCollectionResponse_Track_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse::kTypeFieldNumber;
const int AudioCollectionResponse::kErrorFieldNumber;
const int AudioCollectionResponse::kRevisionFieldNumber;
const int AudioCollectionResponse::kGenreListFieldNumber;
const int AudioCollectionResponse::kArtistListFieldNumber;
const int AudioCollectionResponse::kReleaseListFieldNumber;
const int AudioCollectionResponse::kTrackListFieldNumber;
const int AudioCollectionResponse::kCoverArtFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse::AudioCollectionResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse::InitAsDefaultInstance() {
  error_ = const_cast< ::Remote::Error*>(&::Remote::Error::default_instance());
  revision_ = const_cast< ::Remote::AudioCollectionResponse_Revision*>(&::Remote::AudioCollectionResponse_Revision::default_instance());
  genre_list_ = const_cast< ::Remote::AudioCollectionResponse_GenreList*>(&::Remote::AudioCollectionResponse_GenreList::default_instance());
  artist_list_ = const_cast< ::Remote::AudioCollectionResponse_ArtistList*>(&::Remote::AudioCollectionResponse_ArtistList::default_instance());
  release_list_ = const_cast< ::Remote::AudioCollectionResponse_ReleaseList*>(&::Remote::AudioCollectionResponse_ReleaseList::default_instance());
  track_list_ = const_cast< ::Remote::AudioCollectionResponse_TrackList*>(&::Remote::AudioCollectionResponse_TrackList::default_instance());
}

AudioCollectionResponse::AudioCollectionResponse(const AudioCollectionResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  error_ = NULL;
  revision_ = NULL;
  genre_list_ = NULL;
  artist_list_ = NULL;
  release_list_ = NULL;
  track_list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse::~AudioCollectionResponse() {
  SharedDtor();
}

void AudioCollectionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
    delete revision_;
    delete genre_list_;
    delete artist_list_;
    delete release_list_;
    delete track_list_;
  }
}

void AudioCollectionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_descriptor_;
}

const AudioCollectionResponse& AudioCollectionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse* AudioCollectionResponse::default_instance_ = NULL;

AudioCollectionResponse* AudioCollectionResponse::New() const {
  return new AudioCollectionResponse;
}

void AudioCollectionResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_error()) {
      if (error_ != NULL) error_->::Remote::Error::Clear();
    }
    if (has_revision()) {
      if (revision_ != NULL) revision_->::Remote::AudioCollectionResponse_Revision::Clear();
    }
    if (has_genre_list()) {
      if (genre_list_ != NULL) genre_list_->::Remote::AudioCollectionResponse_GenreList::Clear();
    }
    if (has_artist_list()) {
      if (artist_list_ != NULL) artist_list_->::Remote::AudioCollectionResponse_ArtistList::Clear();
    }
    if (has_release_list()) {
      if (release_list_ != NULL) release_list_->::Remote::AudioCollectionResponse_ReleaseList::Clear();
    }
    if (has_track_list()) {
      if (track_list_ != NULL) track_list_->::Remote::AudioCollectionResponse_TrackList::Clear();
    }
  }
  cover_art_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Remote.AudioCollectionResponse.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Remote::AudioCollectionResponse_Type_IsValid(value)) {
            set_type(static_cast< ::Remote::AudioCollectionResponse_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_error;
        break;
      }

      // optional .Remote.Error error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_revision;
        break;
      }

      // optional .Remote.AudioCollectionResponse.Revision revision = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_revision:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_revision()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_genre_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.GenreList genre_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genre_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_genre_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_artist_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_artist_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_release_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_release_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_track_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.TrackList track_list = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_track_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_track_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_cover_art;
        break;
      }

      // repeated .Remote.AudioCollectionResponse.CoverArt cover_art = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cover_art:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cover_art()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_cover_art;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Remote.AudioCollectionResponse.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .Remote.Error error = 2;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->error(), output);
  }

  // optional .Remote.AudioCollectionResponse.Revision revision = 3;
  if (has_revision()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->revision(), output);
  }

  // optional .Remote.AudioCollectionResponse.GenreList genre_list = 4;
  if (has_genre_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->genre_list(), output);
  }

  // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 5;
  if (has_artist_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->artist_list(), output);
  }

  // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 6;
  if (has_release_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->release_list(), output);
  }

  // optional .Remote.AudioCollectionResponse.TrackList track_list = 7;
  if (has_track_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->track_list(), output);
  }

  // repeated .Remote.AudioCollectionResponse.CoverArt cover_art = 8;
  for (int i = 0; i < this->cover_art_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->cover_art(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Remote.AudioCollectionResponse.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .Remote.Error error = 2;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->error(), target);
  }

  // optional .Remote.AudioCollectionResponse.Revision revision = 3;
  if (has_revision()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->revision(), target);
  }

  // optional .Remote.AudioCollectionResponse.GenreList genre_list = 4;
  if (has_genre_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->genre_list(), target);
  }

  // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 5;
  if (has_artist_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->artist_list(), target);
  }

  // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 6;
  if (has_release_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->release_list(), target);
  }

  // optional .Remote.AudioCollectionResponse.TrackList track_list = 7;
  if (has_track_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->track_list(), target);
  }

  // repeated .Remote.AudioCollectionResponse.CoverArt cover_art = 8;
  for (int i = 0; i < this->cover_art_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->cover_art(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Remote.AudioCollectionResponse.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Remote.Error error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

    // optional .Remote.AudioCollectionResponse.Revision revision = 3;
    if (has_revision()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->revision());
    }

    // optional .Remote.AudioCollectionResponse.GenreList genre_list = 4;
    if (has_genre_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->genre_list());
    }

    // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 5;
    if (has_artist_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->artist_list());
    }

    // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 6;
    if (has_release_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->release_list());
    }

    // optional .Remote.AudioCollectionResponse.TrackList track_list = 7;
    if (has_track_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->track_list());
    }

  }
  // repeated .Remote.AudioCollectionResponse.CoverArt cover_art = 8;
  total_size += 1 * this->cover_art_size();
  for (int i = 0; i < this->cover_art_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cover_art(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse::MergeFrom(const AudioCollectionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  cover_art_.MergeFrom(from.cover_art_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_error()) {
      mutable_error()->::Remote::Error::MergeFrom(from.error());
    }
    if (from.has_revision()) {
      mutable_revision()->::Remote::AudioCollectionResponse_Revision::MergeFrom(from.revision());
    }
    if (from.has_genre_list()) {
      mutable_genre_list()->::Remote::AudioCollectionResponse_GenreList::MergeFrom(from.genre_list());
    }
    if (from.has_artist_list()) {
      mutable_artist_list()->::Remote::AudioCollectionResponse_ArtistList::MergeFrom(from.artist_list());
    }
    if (from.has_release_list()) {
      mutable_release_list()->::Remote::AudioCollectionResponse_ReleaseList::MergeFrom(from.release_list());
    }
    if (from.has_track_list()) {
      mutable_track_list()->::Remote::AudioCollectionResponse_TrackList::MergeFrom(from.track_list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse::CopyFrom(const AudioCollectionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse::IsInitialized() const {

  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  if (has_revision()) {
    if (!this->revision().IsInitialized()) return false;
  }
  if (has_genre_list()) {
    if (!this->genre_list().IsInitialized()) return false;
  }
  if (has_artist_list()) {
    if (!this->artist_list().IsInitialized()) return false;
  }
  if (has_release_list()) {
    if (!this->release_list().IsInitialized()) return false;
  }
  if (has_track_list()) {
    if (!this->track_list().IsInitialized()) return false;
  }
  for (int i = 0; i < cover_art_size(); i++) {
    if (!this->cover_art(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse::Swap(AudioCollectionResponse* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(error_, other->error_);
    std::swap(revision_, other->revision_);
    std::swap(genre_list_, other->genre_list_);
    std::swap(artist_list_, other->artist_list_);
    std::swap(release_list_, other->release_list_);
    std::swap(track_list_, other->track_list_);
    cover_art_.Swap(&other->cover_art_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_descriptor_;
  metadata.reflection = AudioCollectionResponse_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Remote

// @@protoc_insertion_point(global_scope)
