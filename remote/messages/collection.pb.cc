// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collection.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "collection.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Remote {

namespace {

const ::google::protobuf::Descriptor* AudioCollectionRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_BatchParameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_BatchParameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetGenreList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetGenreList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetArtistList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetArtistList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetReleaseList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetReleaseList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetTrackList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionRequest_GetTrackList_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_GenreList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_GenreList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_ArtistList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_ArtistList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_ReleaseList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_ReleaseList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_TrackList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_TrackList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Genre_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Genre_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_CoverArt_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_CoverArt_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Artist_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Artist_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Release_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Release_reflection_ = NULL;
const ::google::protobuf::Descriptor* AudioCollectionResponse_Track_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AudioCollectionResponse_Track_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AudioCollectionResponse_Type_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_collection_2eproto() {
  protobuf_AddDesc_collection_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "collection.proto");
  GOOGLE_CHECK(file != NULL);
  AudioCollectionRequest_descriptor_ = file->message_type(0);
  static const int AudioCollectionRequest_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_genres_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_artists_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_releases_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, get_tracks_),
  };
  AudioCollectionRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_descriptor_,
      AudioCollectionRequest::default_instance_,
      AudioCollectionRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest));
  AudioCollectionRequest_BatchParameter_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(0);
  static const int AudioCollectionRequest_BatchParameter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, offset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, size_),
  };
  AudioCollectionRequest_BatchParameter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_BatchParameter_descriptor_,
      AudioCollectionRequest_BatchParameter::default_instance_,
      AudioCollectionRequest_BatchParameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_BatchParameter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_BatchParameter));
  AudioCollectionRequest_GetGenreList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(1);
  static const int AudioCollectionRequest_GetGenreList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetGenreList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetGenreList, batch_parameter_),
  };
  AudioCollectionRequest_GetGenreList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetGenreList_descriptor_,
      AudioCollectionRequest_GetGenreList::default_instance_,
      AudioCollectionRequest_GetGenreList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetGenreList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetGenreList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetGenreList));
  AudioCollectionRequest_GetArtistList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(2);
  static const int AudioCollectionRequest_GetArtistList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, filter_genre_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, batch_parameter_),
  };
  AudioCollectionRequest_GetArtistList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetArtistList_descriptor_,
      AudioCollectionRequest_GetArtistList::default_instance_,
      AudioCollectionRequest_GetArtistList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetArtistList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetArtistList));
  AudioCollectionRequest_GetReleaseList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(3);
  static const int AudioCollectionRequest_GetReleaseList_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, artist_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, filter_genre_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, get_cover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, batch_parameter_),
  };
  AudioCollectionRequest_GetReleaseList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetReleaseList_descriptor_,
      AudioCollectionRequest_GetReleaseList::default_instance_,
      AudioCollectionRequest_GetReleaseList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetReleaseList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetReleaseList));
  AudioCollectionRequest_GetTrackList_descriptor_ = AudioCollectionRequest_descriptor_->nested_type(4);
  static const int AudioCollectionRequest_GetTrackList_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, filter_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, release_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, artist_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, filter_genre_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, disc_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, track_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, get_cover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, batch_parameter_),
  };
  AudioCollectionRequest_GetTrackList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionRequest_GetTrackList_descriptor_,
      AudioCollectionRequest_GetTrackList::default_instance_,
      AudioCollectionRequest_GetTrackList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionRequest_GetTrackList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionRequest_GetTrackList));
  AudioCollectionRequest_Type_descriptor_ = AudioCollectionRequest_descriptor_->enum_type(0);
  AudioCollectionResponse_descriptor_ = file->message_type(1);
  static const int AudioCollectionResponse_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, genre_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, artist_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, release_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, track_list_),
  };
  AudioCollectionResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_descriptor_,
      AudioCollectionResponse::default_instance_,
      AudioCollectionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse));
  AudioCollectionResponse_GenreList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(0);
  static const int AudioCollectionResponse_GenreList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_GenreList, genres_),
  };
  AudioCollectionResponse_GenreList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_GenreList_descriptor_,
      AudioCollectionResponse_GenreList::default_instance_,
      AudioCollectionResponse_GenreList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_GenreList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_GenreList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_GenreList));
  AudioCollectionResponse_ArtistList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(1);
  static const int AudioCollectionResponse_ArtistList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ArtistList, artists_),
  };
  AudioCollectionResponse_ArtistList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_ArtistList_descriptor_,
      AudioCollectionResponse_ArtistList::default_instance_,
      AudioCollectionResponse_ArtistList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ArtistList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ArtistList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_ArtistList));
  AudioCollectionResponse_ReleaseList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(2);
  static const int AudioCollectionResponse_ReleaseList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ReleaseList, releases_),
  };
  AudioCollectionResponse_ReleaseList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_ReleaseList_descriptor_,
      AudioCollectionResponse_ReleaseList::default_instance_,
      AudioCollectionResponse_ReleaseList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ReleaseList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_ReleaseList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_ReleaseList));
  AudioCollectionResponse_TrackList_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(3);
  static const int AudioCollectionResponse_TrackList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_TrackList, tracks_),
  };
  AudioCollectionResponse_TrackList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_TrackList_descriptor_,
      AudioCollectionResponse_TrackList::default_instance_,
      AudioCollectionResponse_TrackList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_TrackList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_TrackList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_TrackList));
  AudioCollectionResponse_Genre_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(4);
  static const int AudioCollectionResponse_Genre_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Genre, name_),
  };
  AudioCollectionResponse_Genre_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Genre_descriptor_,
      AudioCollectionResponse_Genre::default_instance_,
      AudioCollectionResponse_Genre_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Genre, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Genre, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Genre));
  AudioCollectionResponse_CoverArt_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(5);
  static const int AudioCollectionResponse_CoverArt_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, mime_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, data_),
  };
  AudioCollectionResponse_CoverArt_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_CoverArt_descriptor_,
      AudioCollectionResponse_CoverArt::default_instance_,
      AudioCollectionResponse_CoverArt_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_CoverArt, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_CoverArt));
  AudioCollectionResponse_Artist_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(6);
  static const int AudioCollectionResponse_Artist_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, nb_releases_),
  };
  AudioCollectionResponse_Artist_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Artist_descriptor_,
      AudioCollectionResponse_Artist::default_instance_,
      AudioCollectionResponse_Artist_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Artist, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Artist));
  AudioCollectionResponse_Release_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(7);
  static const int AudioCollectionResponse_Release_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, nb_tracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, duration_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, coverart_),
  };
  AudioCollectionResponse_Release_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Release_descriptor_,
      AudioCollectionResponse_Release::default_instance_,
      AudioCollectionResponse_Release_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Release, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Release));
  AudioCollectionResponse_Track_descriptor_ = AudioCollectionResponse_descriptor_->nested_type(8);
  static const int AudioCollectionResponse_Track_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, media_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, disc_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, track_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, artist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, release_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, duration_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, release_date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, original_release_date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, genres_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, coverart_),
  };
  AudioCollectionResponse_Track_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AudioCollectionResponse_Track_descriptor_,
      AudioCollectionResponse_Track::default_instance_,
      AudioCollectionResponse_Track_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AudioCollectionResponse_Track, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AudioCollectionResponse_Track));
  AudioCollectionResponse_Type_descriptor_ = AudioCollectionResponse_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_collection_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_descriptor_, &AudioCollectionRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_BatchParameter_descriptor_, &AudioCollectionRequest_BatchParameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetGenreList_descriptor_, &AudioCollectionRequest_GetGenreList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetArtistList_descriptor_, &AudioCollectionRequest_GetArtistList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetReleaseList_descriptor_, &AudioCollectionRequest_GetReleaseList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionRequest_GetTrackList_descriptor_, &AudioCollectionRequest_GetTrackList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_descriptor_, &AudioCollectionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_GenreList_descriptor_, &AudioCollectionResponse_GenreList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_ArtistList_descriptor_, &AudioCollectionResponse_ArtistList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_ReleaseList_descriptor_, &AudioCollectionResponse_ReleaseList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_TrackList_descriptor_, &AudioCollectionResponse_TrackList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Genre_descriptor_, &AudioCollectionResponse_Genre::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_CoverArt_descriptor_, &AudioCollectionResponse_CoverArt::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Artist_descriptor_, &AudioCollectionResponse_Artist::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Release_descriptor_, &AudioCollectionResponse_Release::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AudioCollectionResponse_Track_descriptor_, &AudioCollectionResponse_Track::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_collection_2eproto() {
  delete AudioCollectionRequest::default_instance_;
  delete AudioCollectionRequest_reflection_;
  delete AudioCollectionRequest_BatchParameter::default_instance_;
  delete AudioCollectionRequest_BatchParameter_reflection_;
  delete AudioCollectionRequest_GetGenreList::default_instance_;
  delete AudioCollectionRequest_GetGenreList_reflection_;
  delete AudioCollectionRequest_GetArtistList::default_instance_;
  delete AudioCollectionRequest_GetArtistList_reflection_;
  delete AudioCollectionRequest_GetReleaseList::default_instance_;
  delete AudioCollectionRequest_GetReleaseList_reflection_;
  delete AudioCollectionRequest_GetTrackList::default_instance_;
  delete AudioCollectionRequest_GetTrackList_reflection_;
  delete AudioCollectionResponse::default_instance_;
  delete AudioCollectionResponse_reflection_;
  delete AudioCollectionResponse_GenreList::default_instance_;
  delete AudioCollectionResponse_GenreList_reflection_;
  delete AudioCollectionResponse_ArtistList::default_instance_;
  delete AudioCollectionResponse_ArtistList_reflection_;
  delete AudioCollectionResponse_ReleaseList::default_instance_;
  delete AudioCollectionResponse_ReleaseList_reflection_;
  delete AudioCollectionResponse_TrackList::default_instance_;
  delete AudioCollectionResponse_TrackList_reflection_;
  delete AudioCollectionResponse_Genre::default_instance_;
  delete AudioCollectionResponse_Genre_reflection_;
  delete AudioCollectionResponse_CoverArt::default_instance_;
  delete AudioCollectionResponse_CoverArt_reflection_;
  delete AudioCollectionResponse_Artist::default_instance_;
  delete AudioCollectionResponse_Artist_reflection_;
  delete AudioCollectionResponse_Release::default_instance_;
  delete AudioCollectionResponse_Release_reflection_;
  delete AudioCollectionResponse_Track::default_instance_;
  delete AudioCollectionResponse_Track_reflection_;
}

void protobuf_AddDesc_collection_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Remote::protobuf_AddDesc_common_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\020collection.proto\022\006Remote\032\014common.proto"
    "\"\365\010\n\026AudioCollectionRequest\0221\n\004type\030\001 \002("
    "\0162#.Remote.AudioCollectionRequest.Type\022\?"
    "\n\nget_genres\030\002 \001(\0132+.Remote.AudioCollect"
    "ionRequest.GetGenreList\022A\n\013get_artists\030\003"
    " \001(\0132,.Remote.AudioCollectionRequest.Get"
    "ArtistList\022C\n\014get_releases\030\004 \001(\0132-.Remot"
    "e.AudioCollectionRequest.GetReleaseList\022"
    "\?\n\nget_tracks\030\005 \001(\0132+.Remote.AudioCollec"
    "tionRequest.GetTrackList\032.\n\016BatchParamet"
    "er\022\016\n\006offset\030\001 \002(\r\022\014\n\004size\030\002 \002(\r\032k\n\014GetG"
    "enreList\022\023\n\013filter_name\030\001 \001(\t\022F\n\017batch_p"
    "arameter\030\002 \002(\0132-.Remote.AudioCollectionR"
    "equest.BatchParameter\032\202\001\n\rGetArtistList\022"
    "\023\n\013filter_name\030\001 \001(\t\022\024\n\014filter_genre\030\002 \003"
    "(\t\022F\n\017batch_parameter\030\003 \002(\0132-.Remote.Aud"
    "ioCollectionRequest.BatchParameter\032\253\001\n\016G"
    "etReleaseList\022\023\n\013filter_name\030\001 \001(\t\022\023\n\013ar"
    "tist_name\030\002 \003(\t\022\024\n\014filter_genre\030\003 \003(\t\022\021\n"
    "\tget_cover\030\004 \001(\010\022F\n\017batch_parameter\030\005 \002("
    "\0132-.Remote.AudioCollectionRequest.BatchP"
    "arameter\032\352\001\n\014GetTrackList\022\023\n\013filter_name"
    "\030\001 \001(\t\022\024\n\014release_name\030\002 \003(\t\022\023\n\013artist_n"
    "ame\030\003 \003(\t\022\024\n\014filter_genre\030\004 \003(\t\022\023\n\013disc_"
    "number\030\005 \001(\r\022\024\n\014track_number\030\006 \001(\r\022\021\n\tge"
    "t_cover\030\007 \001(\010\022F\n\017batch_parameter\030\010 \002(\0132-"
    ".Remote.AudioCollectionRequest.BatchPara"
    "meter\"a\n\004Type\022\024\n\020TypeGetGenreList\020\001\022\025\n\021T"
    "ypeGetArtistList\020\002\022\026\n\022TypeGetReleaseList"
    "\020\003\022\024\n\020TypeGetTrackList\020\004\"\300\t\n\027AudioCollec"
    "tionResponse\0222\n\004type\030\001 \001(\0162$.Remote.Audi"
    "oCollectionResponse.Type\022\034\n\005error\030\002 \001(\0132"
    "\r.Remote.Error\022=\n\ngenre_list\030\003 \001(\0132).Rem"
    "ote.AudioCollectionResponse.GenreList\022\?\n"
    "\013artist_list\030\004 \001(\0132*.Remote.AudioCollect"
    "ionResponse.ArtistList\022A\n\014release_list\030\005"
    " \001(\0132+.Remote.AudioCollectionResponse.Re"
    "leaseList\022=\n\ntrack_list\030\006 \001(\0132).Remote.A"
    "udioCollectionResponse.TrackList\032B\n\tGenr"
    "eList\0225\n\006genres\030\002 \003(\0132%.Remote.AudioColl"
    "ectionResponse.Genre\032E\n\nArtistList\0227\n\007ar"
    "tists\030\002 \003(\0132&.Remote.AudioCollectionResp"
    "onse.Artist\032H\n\013ReleaseList\0229\n\010releases\030\002"
    " \003(\0132\'.Remote.AudioCollectionResponse.Re"
    "lease\032B\n\tTrackList\0225\n\006tracks\030\002 \003(\0132%.Rem"
    "ote.AudioCollectionResponse.Track\032\025\n\005Gen"
    "re\022\014\n\004name\030\001 \002(\t\032+\n\010CoverArt\022\021\n\tmime_typ"
    "e\030\001 \001(\t\022\014\n\004data\030\002 \003(\014\032+\n\006Artist\022\014\n\004name\030"
    "\001 \002(\t\022\023\n\013nb_releases\030\002 \002(\r\032}\n\007Release\022\014\n"
    "\004name\030\001 \002(\t\022\021\n\tnb_tracks\030\002 \002(\r\022\025\n\rdurati"
    "on_secs\030\003 \002(\r\022:\n\010coverArt\030\004 \001(\0132(.Remote"
    ".AudioCollectionResponse.CoverArt\032\341\001\n\005Tr"
    "ack\022\020\n\010media_id\030\001 \002(\003\022\023\n\013disc_number\030\002 \001"
    "(\r\022\024\n\014track_number\030\003 \001(\r\022\016\n\006artist\030\004 \001(\t"
    "\022\017\n\007release\030\005 \001(\t\022\014\n\004name\030\006 \002(\t\022\025\n\rdurat"
    "ion_secs\030\007 \002(\r\022\024\n\014release_date\030\010 \001(\t\022\035\n\025"
    "original_release_date\030\t \001(\t\022\016\n\006genres\030\n "
    "\003(\t\022\020\n\010coverArt\030\013 \001(\014\"d\n\004Type\022\r\n\tTypeErr"
    "or\020\001\022\021\n\rTypeGenreList\020\002\022\022\n\016TypeArtistLis"
    "t\020\003\022\023\n\017TypeReleaseList\020\004\022\021\n\rTypeTrackLis"
    "t\020\005", 2403);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "collection.proto", &protobuf_RegisterTypes);
  AudioCollectionRequest::default_instance_ = new AudioCollectionRequest();
  AudioCollectionRequest_BatchParameter::default_instance_ = new AudioCollectionRequest_BatchParameter();
  AudioCollectionRequest_GetGenreList::default_instance_ = new AudioCollectionRequest_GetGenreList();
  AudioCollectionRequest_GetArtistList::default_instance_ = new AudioCollectionRequest_GetArtistList();
  AudioCollectionRequest_GetReleaseList::default_instance_ = new AudioCollectionRequest_GetReleaseList();
  AudioCollectionRequest_GetTrackList::default_instance_ = new AudioCollectionRequest_GetTrackList();
  AudioCollectionResponse::default_instance_ = new AudioCollectionResponse();
  AudioCollectionResponse_GenreList::default_instance_ = new AudioCollectionResponse_GenreList();
  AudioCollectionResponse_ArtistList::default_instance_ = new AudioCollectionResponse_ArtistList();
  AudioCollectionResponse_ReleaseList::default_instance_ = new AudioCollectionResponse_ReleaseList();
  AudioCollectionResponse_TrackList::default_instance_ = new AudioCollectionResponse_TrackList();
  AudioCollectionResponse_Genre::default_instance_ = new AudioCollectionResponse_Genre();
  AudioCollectionResponse_CoverArt::default_instance_ = new AudioCollectionResponse_CoverArt();
  AudioCollectionResponse_Artist::default_instance_ = new AudioCollectionResponse_Artist();
  AudioCollectionResponse_Release::default_instance_ = new AudioCollectionResponse_Release();
  AudioCollectionResponse_Track::default_instance_ = new AudioCollectionResponse_Track();
  AudioCollectionRequest::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_BatchParameter::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetGenreList::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetArtistList::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetReleaseList::default_instance_->InitAsDefaultInstance();
  AudioCollectionRequest_GetTrackList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_GenreList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_ArtistList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_ReleaseList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_TrackList::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Genre::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_CoverArt::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Artist::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Release::default_instance_->InitAsDefaultInstance();
  AudioCollectionResponse_Track::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_collection_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_collection_2eproto {
  StaticDescriptorInitializer_collection_2eproto() {
    protobuf_AddDesc_collection_2eproto();
  }
} static_descriptor_initializer_collection_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_Type_descriptor_;
}
bool AudioCollectionRequest_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetGenreList;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetArtistList;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetReleaseList;
const AudioCollectionRequest_Type AudioCollectionRequest::TypeGetTrackList;
const AudioCollectionRequest_Type AudioCollectionRequest::Type_MIN;
const AudioCollectionRequest_Type AudioCollectionRequest::Type_MAX;
const int AudioCollectionRequest::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AudioCollectionRequest_BatchParameter::kOffsetFieldNumber;
const int AudioCollectionRequest_BatchParameter::kSizeFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_BatchParameter::AudioCollectionRequest_BatchParameter()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_BatchParameter::InitAsDefaultInstance() {
}

AudioCollectionRequest_BatchParameter::AudioCollectionRequest_BatchParameter(const AudioCollectionRequest_BatchParameter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_BatchParameter::SharedCtor() {
  _cached_size_ = 0;
  offset_ = 0u;
  size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_BatchParameter::~AudioCollectionRequest_BatchParameter() {
  SharedDtor();
}

void AudioCollectionRequest_BatchParameter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionRequest_BatchParameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_BatchParameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_BatchParameter_descriptor_;
}

const AudioCollectionRequest_BatchParameter& AudioCollectionRequest_BatchParameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_BatchParameter* AudioCollectionRequest_BatchParameter::default_instance_ = NULL;

AudioCollectionRequest_BatchParameter* AudioCollectionRequest_BatchParameter::New() const {
  return new AudioCollectionRequest_BatchParameter;
}

void AudioCollectionRequest_BatchParameter::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    offset_ = 0u;
    size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_BatchParameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 offset = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }

      // required uint32 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_BatchParameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 offset = 1;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->offset(), output);
  }

  // required uint32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_BatchParameter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 offset = 1;
  if (has_offset()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->offset(), target);
  }

  // required uint32 size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_BatchParameter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // required uint32 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_BatchParameter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_BatchParameter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_BatchParameter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_BatchParameter::MergeFrom(const AudioCollectionRequest_BatchParameter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_BatchParameter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_BatchParameter::CopyFrom(const AudioCollectionRequest_BatchParameter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_BatchParameter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AudioCollectionRequest_BatchParameter::Swap(AudioCollectionRequest_BatchParameter* other) {
  if (other != this) {
    std::swap(offset_, other->offset_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_BatchParameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_BatchParameter_descriptor_;
  metadata.reflection = AudioCollectionRequest_BatchParameter_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetGenreList::kFilterNameFieldNumber;
const int AudioCollectionRequest_GetGenreList::kBatchParameterFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetGenreList::AudioCollectionRequest_GetGenreList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetGenreList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetGenreList::AudioCollectionRequest_GetGenreList(const AudioCollectionRequest_GetGenreList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetGenreList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetGenreList::~AudioCollectionRequest_GetGenreList() {
  SharedDtor();
}

void AudioCollectionRequest_GetGenreList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetGenreList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetGenreList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetGenreList_descriptor_;
}

const AudioCollectionRequest_GetGenreList& AudioCollectionRequest_GetGenreList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetGenreList* AudioCollectionRequest_GetGenreList::default_instance_ = NULL;

AudioCollectionRequest_GetGenreList* AudioCollectionRequest_GetGenreList::New() const {
  return new AudioCollectionRequest_GetGenreList;
}

void AudioCollectionRequest_GetGenreList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetGenreList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_batch_parameter;
        break;
      }

      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_batch_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetGenreList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 2;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->batch_parameter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetGenreList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 2;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->batch_parameter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetGenreList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 2;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetGenreList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetGenreList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetGenreList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetGenreList::MergeFrom(const AudioCollectionRequest_GetGenreList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetGenreList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetGenreList::CopyFrom(const AudioCollectionRequest_GetGenreList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetGenreList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetGenreList::Swap(AudioCollectionRequest_GetGenreList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    std::swap(batch_parameter_, other->batch_parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetGenreList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetGenreList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetGenreList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetArtistList::kFilterNameFieldNumber;
const int AudioCollectionRequest_GetArtistList::kFilterGenreFieldNumber;
const int AudioCollectionRequest_GetArtistList::kBatchParameterFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetArtistList::AudioCollectionRequest_GetArtistList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetArtistList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetArtistList::AudioCollectionRequest_GetArtistList(const AudioCollectionRequest_GetArtistList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetArtistList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetArtistList::~AudioCollectionRequest_GetArtistList() {
  SharedDtor();
}

void AudioCollectionRequest_GetArtistList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetArtistList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetArtistList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetArtistList_descriptor_;
}

const AudioCollectionRequest_GetArtistList& AudioCollectionRequest_GetArtistList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetArtistList* AudioCollectionRequest_GetArtistList::default_instance_ = NULL;

AudioCollectionRequest_GetArtistList* AudioCollectionRequest_GetArtistList::New() const {
  return new AudioCollectionRequest_GetArtistList;
}

void AudioCollectionRequest_GetArtistList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  filter_genre_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetArtistList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filter_genre;
        break;
      }

      // repeated string filter_genre = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_genre:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_genre()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_genre(this->filter_genre_size() - 1).data(),
            this->filter_genre(this->filter_genre_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filter_genre;
        if (input->ExpectTag(26)) goto parse_batch_parameter;
        break;
      }

      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_batch_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetArtistList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // repeated string filter_genre = 2;
  for (int i = 0; i < this->filter_genre_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->filter_genre(i).data(), this->filter_genre(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->filter_genre(i), output);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 3;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->batch_parameter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetArtistList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // repeated string filter_genre = 2;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_genre(i).data(), this->filter_genre(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->filter_genre(i), target);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 3;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->batch_parameter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetArtistList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 3;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  // repeated string filter_genre = 2;
  total_size += 1 * this->filter_genre_size();
  for (int i = 0; i < this->filter_genre_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_genre(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetArtistList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetArtistList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetArtistList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetArtistList::MergeFrom(const AudioCollectionRequest_GetArtistList& from) {
  GOOGLE_CHECK_NE(&from, this);
  filter_genre_.MergeFrom(from.filter_genre_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetArtistList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetArtistList::CopyFrom(const AudioCollectionRequest_GetArtistList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetArtistList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetArtistList::Swap(AudioCollectionRequest_GetArtistList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    filter_genre_.Swap(&other->filter_genre_);
    std::swap(batch_parameter_, other->batch_parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetArtistList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetArtistList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetArtistList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetReleaseList::kFilterNameFieldNumber;
const int AudioCollectionRequest_GetReleaseList::kArtistNameFieldNumber;
const int AudioCollectionRequest_GetReleaseList::kFilterGenreFieldNumber;
const int AudioCollectionRequest_GetReleaseList::kGetCoverFieldNumber;
const int AudioCollectionRequest_GetReleaseList::kBatchParameterFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetReleaseList::AudioCollectionRequest_GetReleaseList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetReleaseList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetReleaseList::AudioCollectionRequest_GetReleaseList(const AudioCollectionRequest_GetReleaseList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetReleaseList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  get_cover_ = false;
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetReleaseList::~AudioCollectionRequest_GetReleaseList() {
  SharedDtor();
}

void AudioCollectionRequest_GetReleaseList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetReleaseList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetReleaseList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetReleaseList_descriptor_;
}

const AudioCollectionRequest_GetReleaseList& AudioCollectionRequest_GetReleaseList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetReleaseList* AudioCollectionRequest_GetReleaseList::default_instance_ = NULL;

AudioCollectionRequest_GetReleaseList* AudioCollectionRequest_GetReleaseList::New() const {
  return new AudioCollectionRequest_GetReleaseList;
}

void AudioCollectionRequest_GetReleaseList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    get_cover_ = false;
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  artist_name_.Clear();
  filter_genre_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetReleaseList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artist_name;
        break;
      }

      // repeated string artist_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_artist_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist_name(this->artist_name_size() - 1).data(),
            this->artist_name(this->artist_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artist_name;
        if (input->ExpectTag(26)) goto parse_filter_genre;
        break;
      }

      // repeated string filter_genre = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_genre:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_genre()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_genre(this->filter_genre_size() - 1).data(),
            this->filter_genre(this->filter_genre_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_filter_genre;
        if (input->ExpectTag(32)) goto parse_get_cover;
        break;
      }

      // optional bool get_cover = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_get_cover:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &get_cover_)));
          set_has_get_cover();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_batch_parameter;
        break;
      }

      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_batch_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetReleaseList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // repeated string artist_name = 2;
  for (int i = 0; i < this->artist_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->artist_name(i).data(), this->artist_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->artist_name(i), output);
  }

  // repeated string filter_genre = 3;
  for (int i = 0; i < this->filter_genre_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->filter_genre(i).data(), this->filter_genre(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->filter_genre(i), output);
  }

  // optional bool get_cover = 4;
  if (has_get_cover()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->get_cover(), output);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 5;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->batch_parameter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetReleaseList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // repeated string artist_name = 2;
  for (int i = 0; i < this->artist_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist_name(i).data(), this->artist_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->artist_name(i), target);
  }

  // repeated string filter_genre = 3;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_genre(i).data(), this->filter_genre(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->filter_genre(i), target);
  }

  // optional bool get_cover = 4;
  if (has_get_cover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->get_cover(), target);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 5;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->batch_parameter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetReleaseList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // optional bool get_cover = 4;
    if (has_get_cover()) {
      total_size += 1 + 1;
    }

    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 5;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  // repeated string artist_name = 2;
  total_size += 1 * this->artist_name_size();
  for (int i = 0; i < this->artist_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->artist_name(i));
  }

  // repeated string filter_genre = 3;
  total_size += 1 * this->filter_genre_size();
  for (int i = 0; i < this->filter_genre_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_genre(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetReleaseList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetReleaseList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetReleaseList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetReleaseList::MergeFrom(const AudioCollectionRequest_GetReleaseList& from) {
  GOOGLE_CHECK_NE(&from, this);
  artist_name_.MergeFrom(from.artist_name_);
  filter_genre_.MergeFrom(from.filter_genre_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_get_cover()) {
      set_get_cover(from.get_cover());
    }
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetReleaseList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetReleaseList::CopyFrom(const AudioCollectionRequest_GetReleaseList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetReleaseList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000010) != 0x00000010) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetReleaseList::Swap(AudioCollectionRequest_GetReleaseList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    artist_name_.Swap(&other->artist_name_);
    filter_genre_.Swap(&other->filter_genre_);
    std::swap(get_cover_, other->get_cover_);
    std::swap(batch_parameter_, other->batch_parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetReleaseList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetReleaseList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetReleaseList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest_GetTrackList::kFilterNameFieldNumber;
const int AudioCollectionRequest_GetTrackList::kReleaseNameFieldNumber;
const int AudioCollectionRequest_GetTrackList::kArtistNameFieldNumber;
const int AudioCollectionRequest_GetTrackList::kFilterGenreFieldNumber;
const int AudioCollectionRequest_GetTrackList::kDiscNumberFieldNumber;
const int AudioCollectionRequest_GetTrackList::kTrackNumberFieldNumber;
const int AudioCollectionRequest_GetTrackList::kGetCoverFieldNumber;
const int AudioCollectionRequest_GetTrackList::kBatchParameterFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest_GetTrackList::AudioCollectionRequest_GetTrackList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest_GetTrackList::InitAsDefaultInstance() {
  batch_parameter_ = const_cast< ::Remote::AudioCollectionRequest_BatchParameter*>(&::Remote::AudioCollectionRequest_BatchParameter::default_instance());
}

AudioCollectionRequest_GetTrackList::AudioCollectionRequest_GetTrackList(const AudioCollectionRequest_GetTrackList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest_GetTrackList::SharedCtor() {
  _cached_size_ = 0;
  filter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  disc_number_ = 0u;
  track_number_ = 0u;
  get_cover_ = false;
  batch_parameter_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest_GetTrackList::~AudioCollectionRequest_GetTrackList() {
  SharedDtor();
}

void AudioCollectionRequest_GetTrackList::SharedDtor() {
  if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_name_;
  }
  if (this != default_instance_) {
    delete batch_parameter_;
  }
}

void AudioCollectionRequest_GetTrackList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest_GetTrackList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_GetTrackList_descriptor_;
}

const AudioCollectionRequest_GetTrackList& AudioCollectionRequest_GetTrackList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest_GetTrackList* AudioCollectionRequest_GetTrackList::default_instance_ = NULL;

AudioCollectionRequest_GetTrackList* AudioCollectionRequest_GetTrackList::New() const {
  return new AudioCollectionRequest_GetTrackList;
}

void AudioCollectionRequest_GetTrackList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filter_name()) {
      if (filter_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_name_->clear();
      }
    }
    disc_number_ = 0u;
    track_number_ = 0u;
    get_cover_ = false;
    if (has_batch_parameter()) {
      if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
    }
  }
  release_name_.Clear();
  artist_name_.Clear();
  filter_genre_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest_GetTrackList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string filter_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_name().data(), this->filter_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_release_name;
        break;
      }

      // repeated string release_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_release_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release_name(this->release_name_size() - 1).data(),
            this->release_name(this->release_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_release_name;
        if (input->ExpectTag(26)) goto parse_artist_name;
        break;
      }

      // repeated string artist_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_artist_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist_name(this->artist_name_size() - 1).data(),
            this->artist_name(this->artist_name_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_artist_name;
        if (input->ExpectTag(34)) goto parse_filter_genre;
        break;
      }

      // repeated string filter_genre = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_genre:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_genre()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filter_genre(this->filter_genre_size() - 1).data(),
            this->filter_genre(this->filter_genre_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_filter_genre;
        if (input->ExpectTag(40)) goto parse_disc_number;
        break;
      }

      // optional uint32 disc_number = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_disc_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &disc_number_)));
          set_has_disc_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_track_number;
        break;
      }

      // optional uint32 track_number = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_track_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &track_number_)));
          set_has_track_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_get_cover;
        break;
      }

      // optional bool get_cover = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_get_cover:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &get_cover_)));
          set_has_get_cover();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_batch_parameter;
        break;
      }

      // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_batch_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_batch_parameter()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest_GetTrackList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filter_name(), output);
  }

  // repeated string release_name = 2;
  for (int i = 0; i < this->release_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->release_name(i).data(), this->release_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->release_name(i), output);
  }

  // repeated string artist_name = 3;
  for (int i = 0; i < this->artist_name_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->artist_name(i).data(), this->artist_name(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->artist_name(i), output);
  }

  // repeated string filter_genre = 4;
  for (int i = 0; i < this->filter_genre_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->filter_genre(i).data(), this->filter_genre(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->filter_genre(i), output);
  }

  // optional uint32 disc_number = 5;
  if (has_disc_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->disc_number(), output);
  }

  // optional uint32 track_number = 6;
  if (has_track_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->track_number(), output);
  }

  // optional bool get_cover = 7;
  if (has_get_cover()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->get_cover(), output);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 8;
  if (has_batch_parameter()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->batch_parameter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest_GetTrackList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string filter_name = 1;
  if (has_filter_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_name().data(), this->filter_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filter_name(), target);
  }

  // repeated string release_name = 2;
  for (int i = 0; i < this->release_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_name(i).data(), this->release_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(2, this->release_name(i), target);
  }

  // repeated string artist_name = 3;
  for (int i = 0; i < this->artist_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist_name(i).data(), this->artist_name(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->artist_name(i), target);
  }

  // repeated string filter_genre = 4;
  for (int i = 0; i < this->filter_genre_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filter_genre(i).data(), this->filter_genre(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(4, this->filter_genre(i), target);
  }

  // optional uint32 disc_number = 5;
  if (has_disc_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->disc_number(), target);
  }

  // optional uint32 track_number = 6;
  if (has_track_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->track_number(), target);
  }

  // optional bool get_cover = 7;
  if (has_get_cover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->get_cover(), target);
  }

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 8;
  if (has_batch_parameter()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->batch_parameter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest_GetTrackList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string filter_name = 1;
    if (has_filter_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_name());
    }

    // optional uint32 disc_number = 5;
    if (has_disc_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->disc_number());
    }

    // optional uint32 track_number = 6;
    if (has_track_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->track_number());
    }

    // optional bool get_cover = 7;
    if (has_get_cover()) {
      total_size += 1 + 1;
    }

    // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 8;
    if (has_batch_parameter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->batch_parameter());
    }

  }
  // repeated string release_name = 2;
  total_size += 1 * this->release_name_size();
  for (int i = 0; i < this->release_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->release_name(i));
  }

  // repeated string artist_name = 3;
  total_size += 1 * this->artist_name_size();
  for (int i = 0; i < this->artist_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->artist_name(i));
  }

  // repeated string filter_genre = 4;
  total_size += 1 * this->filter_genre_size();
  for (int i = 0; i < this->filter_genre_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_genre(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest_GetTrackList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest_GetTrackList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest_GetTrackList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest_GetTrackList::MergeFrom(const AudioCollectionRequest_GetTrackList& from) {
  GOOGLE_CHECK_NE(&from, this);
  release_name_.MergeFrom(from.release_name_);
  artist_name_.MergeFrom(from.artist_name_);
  filter_genre_.MergeFrom(from.filter_genre_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filter_name()) {
      set_filter_name(from.filter_name());
    }
    if (from.has_disc_number()) {
      set_disc_number(from.disc_number());
    }
    if (from.has_track_number()) {
      set_track_number(from.track_number());
    }
    if (from.has_get_cover()) {
      set_get_cover(from.get_cover());
    }
    if (from.has_batch_parameter()) {
      mutable_batch_parameter()->::Remote::AudioCollectionRequest_BatchParameter::MergeFrom(from.batch_parameter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest_GetTrackList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest_GetTrackList::CopyFrom(const AudioCollectionRequest_GetTrackList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest_GetTrackList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000080) != 0x00000080) return false;

  if (has_batch_parameter()) {
    if (!this->batch_parameter().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest_GetTrackList::Swap(AudioCollectionRequest_GetTrackList* other) {
  if (other != this) {
    std::swap(filter_name_, other->filter_name_);
    release_name_.Swap(&other->release_name_);
    artist_name_.Swap(&other->artist_name_);
    filter_genre_.Swap(&other->filter_genre_);
    std::swap(disc_number_, other->disc_number_);
    std::swap(track_number_, other->track_number_);
    std::swap(get_cover_, other->get_cover_);
    std::swap(batch_parameter_, other->batch_parameter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest_GetTrackList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_GetTrackList_descriptor_;
  metadata.reflection = AudioCollectionRequest_GetTrackList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionRequest::kTypeFieldNumber;
const int AudioCollectionRequest::kGetGenresFieldNumber;
const int AudioCollectionRequest::kGetArtistsFieldNumber;
const int AudioCollectionRequest::kGetReleasesFieldNumber;
const int AudioCollectionRequest::kGetTracksFieldNumber;
#endif  // !_MSC_VER

AudioCollectionRequest::AudioCollectionRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionRequest::InitAsDefaultInstance() {
  get_genres_ = const_cast< ::Remote::AudioCollectionRequest_GetGenreList*>(&::Remote::AudioCollectionRequest_GetGenreList::default_instance());
  get_artists_ = const_cast< ::Remote::AudioCollectionRequest_GetArtistList*>(&::Remote::AudioCollectionRequest_GetArtistList::default_instance());
  get_releases_ = const_cast< ::Remote::AudioCollectionRequest_GetReleaseList*>(&::Remote::AudioCollectionRequest_GetReleaseList::default_instance());
  get_tracks_ = const_cast< ::Remote::AudioCollectionRequest_GetTrackList*>(&::Remote::AudioCollectionRequest_GetTrackList::default_instance());
}

AudioCollectionRequest::AudioCollectionRequest(const AudioCollectionRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  get_genres_ = NULL;
  get_artists_ = NULL;
  get_releases_ = NULL;
  get_tracks_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionRequest::~AudioCollectionRequest() {
  SharedDtor();
}

void AudioCollectionRequest::SharedDtor() {
  if (this != default_instance_) {
    delete get_genres_;
    delete get_artists_;
    delete get_releases_;
    delete get_tracks_;
  }
}

void AudioCollectionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionRequest_descriptor_;
}

const AudioCollectionRequest& AudioCollectionRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionRequest* AudioCollectionRequest::default_instance_ = NULL;

AudioCollectionRequest* AudioCollectionRequest::New() const {
  return new AudioCollectionRequest;
}

void AudioCollectionRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_get_genres()) {
      if (get_genres_ != NULL) get_genres_->::Remote::AudioCollectionRequest_GetGenreList::Clear();
    }
    if (has_get_artists()) {
      if (get_artists_ != NULL) get_artists_->::Remote::AudioCollectionRequest_GetArtistList::Clear();
    }
    if (has_get_releases()) {
      if (get_releases_ != NULL) get_releases_->::Remote::AudioCollectionRequest_GetReleaseList::Clear();
    }
    if (has_get_tracks()) {
      if (get_tracks_ != NULL) get_tracks_->::Remote::AudioCollectionRequest_GetTrackList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .Remote.AudioCollectionRequest.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Remote::AudioCollectionRequest_Type_IsValid(value)) {
            set_type(static_cast< ::Remote::AudioCollectionRequest_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_get_genres;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_genres()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_get_artists;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_artists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_artists()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_get_releases;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_releases:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_releases()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_get_tracks;
        break;
      }

      // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_get_tracks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_get_tracks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .Remote.AudioCollectionRequest.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
  if (has_get_genres()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->get_genres(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
  if (has_get_artists()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->get_artists(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
  if (has_get_releases()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->get_releases(), output);
  }

  // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
  if (has_get_tracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->get_tracks(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .Remote.AudioCollectionRequest.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
  if (has_get_genres()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->get_genres(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
  if (has_get_artists()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->get_artists(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
  if (has_get_releases()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->get_releases(), target);
  }

  // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
  if (has_get_tracks()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->get_tracks(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .Remote.AudioCollectionRequest.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
    if (has_get_genres()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_genres());
    }

    // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
    if (has_get_artists()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_artists());
    }

    // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
    if (has_get_releases()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_releases());
    }

    // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
    if (has_get_tracks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->get_tracks());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionRequest::MergeFrom(const AudioCollectionRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_get_genres()) {
      mutable_get_genres()->::Remote::AudioCollectionRequest_GetGenreList::MergeFrom(from.get_genres());
    }
    if (from.has_get_artists()) {
      mutable_get_artists()->::Remote::AudioCollectionRequest_GetArtistList::MergeFrom(from.get_artists());
    }
    if (from.has_get_releases()) {
      mutable_get_releases()->::Remote::AudioCollectionRequest_GetReleaseList::MergeFrom(from.get_releases());
    }
    if (from.has_get_tracks()) {
      mutable_get_tracks()->::Remote::AudioCollectionRequest_GetTrackList::MergeFrom(from.get_tracks());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionRequest::CopyFrom(const AudioCollectionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_get_genres()) {
    if (!this->get_genres().IsInitialized()) return false;
  }
  if (has_get_artists()) {
    if (!this->get_artists().IsInitialized()) return false;
  }
  if (has_get_releases()) {
    if (!this->get_releases().IsInitialized()) return false;
  }
  if (has_get_tracks()) {
    if (!this->get_tracks().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionRequest::Swap(AudioCollectionRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(get_genres_, other->get_genres_);
    std::swap(get_artists_, other->get_artists_);
    std::swap(get_releases_, other->get_releases_);
    std::swap(get_tracks_, other->get_tracks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionRequest_descriptor_;
  metadata.reflection = AudioCollectionRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* AudioCollectionResponse_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Type_descriptor_;
}
bool AudioCollectionResponse_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AudioCollectionResponse_Type AudioCollectionResponse::TypeError;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeGenreList;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeArtistList;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeReleaseList;
const AudioCollectionResponse_Type AudioCollectionResponse::TypeTrackList;
const AudioCollectionResponse_Type AudioCollectionResponse::Type_MIN;
const AudioCollectionResponse_Type AudioCollectionResponse::Type_MAX;
const int AudioCollectionResponse::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AudioCollectionResponse_GenreList::kGenresFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_GenreList::AudioCollectionResponse_GenreList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_GenreList::InitAsDefaultInstance() {
}

AudioCollectionResponse_GenreList::AudioCollectionResponse_GenreList(const AudioCollectionResponse_GenreList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_GenreList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_GenreList::~AudioCollectionResponse_GenreList() {
  SharedDtor();
}

void AudioCollectionResponse_GenreList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_GenreList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_GenreList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_GenreList_descriptor_;
}

const AudioCollectionResponse_GenreList& AudioCollectionResponse_GenreList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_GenreList* AudioCollectionResponse_GenreList::default_instance_ = NULL;

AudioCollectionResponse_GenreList* AudioCollectionResponse_GenreList::New() const {
  return new AudioCollectionResponse_GenreList;
}

void AudioCollectionResponse_GenreList::Clear() {
  genres_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_GenreList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_genres()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_genres;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_GenreList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
  for (int i = 0; i < this->genres_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->genres(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_GenreList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
  for (int i = 0; i < this->genres_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->genres(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_GenreList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
  total_size += 1 * this->genres_size();
  for (int i = 0; i < this->genres_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->genres(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_GenreList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_GenreList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_GenreList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_GenreList::MergeFrom(const AudioCollectionResponse_GenreList& from) {
  GOOGLE_CHECK_NE(&from, this);
  genres_.MergeFrom(from.genres_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_GenreList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_GenreList::CopyFrom(const AudioCollectionResponse_GenreList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_GenreList::IsInitialized() const {

  for (int i = 0; i < genres_size(); i++) {
    if (!this->genres(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_GenreList::Swap(AudioCollectionResponse_GenreList* other) {
  if (other != this) {
    genres_.Swap(&other->genres_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_GenreList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_GenreList_descriptor_;
  metadata.reflection = AudioCollectionResponse_GenreList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_ArtistList::kArtistsFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_ArtistList::AudioCollectionResponse_ArtistList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_ArtistList::InitAsDefaultInstance() {
}

AudioCollectionResponse_ArtistList::AudioCollectionResponse_ArtistList(const AudioCollectionResponse_ArtistList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_ArtistList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_ArtistList::~AudioCollectionResponse_ArtistList() {
  SharedDtor();
}

void AudioCollectionResponse_ArtistList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_ArtistList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_ArtistList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_ArtistList_descriptor_;
}

const AudioCollectionResponse_ArtistList& AudioCollectionResponse_ArtistList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_ArtistList* AudioCollectionResponse_ArtistList::default_instance_ = NULL;

AudioCollectionResponse_ArtistList* AudioCollectionResponse_ArtistList::New() const {
  return new AudioCollectionResponse_ArtistList;
}

void AudioCollectionResponse_ArtistList::Clear() {
  artists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_ArtistList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_artists()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_artists;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_ArtistList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
  for (int i = 0; i < this->artists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->artists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_ArtistList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
  for (int i = 0; i < this->artists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->artists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_ArtistList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
  total_size += 1 * this->artists_size();
  for (int i = 0; i < this->artists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->artists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_ArtistList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_ArtistList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_ArtistList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_ArtistList::MergeFrom(const AudioCollectionResponse_ArtistList& from) {
  GOOGLE_CHECK_NE(&from, this);
  artists_.MergeFrom(from.artists_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_ArtistList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_ArtistList::CopyFrom(const AudioCollectionResponse_ArtistList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_ArtistList::IsInitialized() const {

  for (int i = 0; i < artists_size(); i++) {
    if (!this->artists(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_ArtistList::Swap(AudioCollectionResponse_ArtistList* other) {
  if (other != this) {
    artists_.Swap(&other->artists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_ArtistList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_ArtistList_descriptor_;
  metadata.reflection = AudioCollectionResponse_ArtistList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_ReleaseList::kReleasesFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_ReleaseList::AudioCollectionResponse_ReleaseList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_ReleaseList::InitAsDefaultInstance() {
}

AudioCollectionResponse_ReleaseList::AudioCollectionResponse_ReleaseList(const AudioCollectionResponse_ReleaseList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_ReleaseList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_ReleaseList::~AudioCollectionResponse_ReleaseList() {
  SharedDtor();
}

void AudioCollectionResponse_ReleaseList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_ReleaseList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_ReleaseList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_ReleaseList_descriptor_;
}

const AudioCollectionResponse_ReleaseList& AudioCollectionResponse_ReleaseList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_ReleaseList* AudioCollectionResponse_ReleaseList::default_instance_ = NULL;

AudioCollectionResponse_ReleaseList* AudioCollectionResponse_ReleaseList::New() const {
  return new AudioCollectionResponse_ReleaseList;
}

void AudioCollectionResponse_ReleaseList::Clear() {
  releases_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_ReleaseList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Release releases = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_releases:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_releases()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_releases;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_ReleaseList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Release releases = 2;
  for (int i = 0; i < this->releases_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->releases(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_ReleaseList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Release releases = 2;
  for (int i = 0; i < this->releases_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->releases(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_ReleaseList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Release releases = 2;
  total_size += 1 * this->releases_size();
  for (int i = 0; i < this->releases_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->releases(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_ReleaseList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_ReleaseList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_ReleaseList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_ReleaseList::MergeFrom(const AudioCollectionResponse_ReleaseList& from) {
  GOOGLE_CHECK_NE(&from, this);
  releases_.MergeFrom(from.releases_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_ReleaseList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_ReleaseList::CopyFrom(const AudioCollectionResponse_ReleaseList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_ReleaseList::IsInitialized() const {

  for (int i = 0; i < releases_size(); i++) {
    if (!this->releases(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_ReleaseList::Swap(AudioCollectionResponse_ReleaseList* other) {
  if (other != this) {
    releases_.Swap(&other->releases_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_ReleaseList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_ReleaseList_descriptor_;
  metadata.reflection = AudioCollectionResponse_ReleaseList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_TrackList::kTracksFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_TrackList::AudioCollectionResponse_TrackList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_TrackList::InitAsDefaultInstance() {
}

AudioCollectionResponse_TrackList::AudioCollectionResponse_TrackList(const AudioCollectionResponse_TrackList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_TrackList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_TrackList::~AudioCollectionResponse_TrackList() {
  SharedDtor();
}

void AudioCollectionResponse_TrackList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_TrackList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_TrackList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_TrackList_descriptor_;
}

const AudioCollectionResponse_TrackList& AudioCollectionResponse_TrackList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_TrackList* AudioCollectionResponse_TrackList::default_instance_ = NULL;

AudioCollectionResponse_TrackList* AudioCollectionResponse_TrackList::New() const {
  return new AudioCollectionResponse_TrackList;
}

void AudioCollectionResponse_TrackList::Clear() {
  tracks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_TrackList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tracks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tracks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tracks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_TrackList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
  for (int i = 0; i < this->tracks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tracks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_TrackList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
  for (int i = 0; i < this->tracks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tracks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_TrackList::ByteSize() const {
  int total_size = 0;

  // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
  total_size += 1 * this->tracks_size();
  for (int i = 0; i < this->tracks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tracks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_TrackList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_TrackList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_TrackList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_TrackList::MergeFrom(const AudioCollectionResponse_TrackList& from) {
  GOOGLE_CHECK_NE(&from, this);
  tracks_.MergeFrom(from.tracks_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_TrackList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_TrackList::CopyFrom(const AudioCollectionResponse_TrackList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_TrackList::IsInitialized() const {

  for (int i = 0; i < tracks_size(); i++) {
    if (!this->tracks(i).IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse_TrackList::Swap(AudioCollectionResponse_TrackList* other) {
  if (other != this) {
    tracks_.Swap(&other->tracks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_TrackList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_TrackList_descriptor_;
  metadata.reflection = AudioCollectionResponse_TrackList_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Genre::kNameFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Genre::AudioCollectionResponse_Genre()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Genre::InitAsDefaultInstance() {
}

AudioCollectionResponse_Genre::AudioCollectionResponse_Genre(const AudioCollectionResponse_Genre& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Genre::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Genre::~AudioCollectionResponse_Genre() {
  SharedDtor();
}

void AudioCollectionResponse_Genre::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Genre::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Genre::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Genre_descriptor_;
}

const AudioCollectionResponse_Genre& AudioCollectionResponse_Genre::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Genre* AudioCollectionResponse_Genre::default_instance_ = NULL;

AudioCollectionResponse_Genre* AudioCollectionResponse_Genre::New() const {
  return new AudioCollectionResponse_Genre;
}

void AudioCollectionResponse_Genre::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Genre::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Genre::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Genre::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Genre::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Genre::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Genre* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Genre*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Genre::MergeFrom(const AudioCollectionResponse_Genre& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Genre::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Genre::CopyFrom(const AudioCollectionResponse_Genre& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Genre::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AudioCollectionResponse_Genre::Swap(AudioCollectionResponse_Genre* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Genre::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Genre_descriptor_;
  metadata.reflection = AudioCollectionResponse_Genre_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_CoverArt::kMimeTypeFieldNumber;
const int AudioCollectionResponse_CoverArt::kDataFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_CoverArt::AudioCollectionResponse_CoverArt()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_CoverArt::InitAsDefaultInstance() {
}

AudioCollectionResponse_CoverArt::AudioCollectionResponse_CoverArt(const AudioCollectionResponse_CoverArt& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_CoverArt::SharedCtor() {
  _cached_size_ = 0;
  mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_CoverArt::~AudioCollectionResponse_CoverArt() {
  SharedDtor();
}

void AudioCollectionResponse_CoverArt::SharedDtor() {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    delete mime_type_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_CoverArt::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_CoverArt::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_CoverArt_descriptor_;
}

const AudioCollectionResponse_CoverArt& AudioCollectionResponse_CoverArt::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_CoverArt* AudioCollectionResponse_CoverArt::default_instance_ = NULL;

AudioCollectionResponse_CoverArt* AudioCollectionResponse_CoverArt::New() const {
  return new AudioCollectionResponse_CoverArt;
}

void AudioCollectionResponse_CoverArt::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mime_type()) {
      if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
        mime_type_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_CoverArt::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string mime_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mime_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mime_type().data(), this->mime_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated bytes data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_CoverArt::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string mime_type = 1;
  if (has_mime_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mime_type().data(), this->mime_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mime_type(), output);
  }

  // repeated bytes data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_CoverArt::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string mime_type = 1;
  if (has_mime_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mime_type().data(), this->mime_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mime_type(), target);
  }

  // repeated bytes data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_CoverArt::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string mime_type = 1;
    if (has_mime_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mime_type());
    }

  }
  // repeated bytes data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_CoverArt::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_CoverArt* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_CoverArt*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_CoverArt::MergeFrom(const AudioCollectionResponse_CoverArt& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mime_type()) {
      set_mime_type(from.mime_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_CoverArt::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_CoverArt::CopyFrom(const AudioCollectionResponse_CoverArt& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_CoverArt::IsInitialized() const {

  return true;
}

void AudioCollectionResponse_CoverArt::Swap(AudioCollectionResponse_CoverArt* other) {
  if (other != this) {
    std::swap(mime_type_, other->mime_type_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_CoverArt::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_CoverArt_descriptor_;
  metadata.reflection = AudioCollectionResponse_CoverArt_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Artist::kNameFieldNumber;
const int AudioCollectionResponse_Artist::kNbReleasesFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Artist::AudioCollectionResponse_Artist()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Artist::InitAsDefaultInstance() {
}

AudioCollectionResponse_Artist::AudioCollectionResponse_Artist(const AudioCollectionResponse_Artist& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Artist::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nb_releases_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Artist::~AudioCollectionResponse_Artist() {
  SharedDtor();
}

void AudioCollectionResponse_Artist::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Artist::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Artist::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Artist_descriptor_;
}

const AudioCollectionResponse_Artist& AudioCollectionResponse_Artist::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Artist* AudioCollectionResponse_Artist::default_instance_ = NULL;

AudioCollectionResponse_Artist* AudioCollectionResponse_Artist::New() const {
  return new AudioCollectionResponse_Artist;
}

void AudioCollectionResponse_Artist::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    nb_releases_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Artist::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nb_releases;
        break;
      }

      // required uint32 nb_releases = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nb_releases:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nb_releases_)));
          set_has_nb_releases();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Artist::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required uint32 nb_releases = 2;
  if (has_nb_releases()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->nb_releases(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Artist::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 nb_releases = 2;
  if (has_nb_releases()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->nb_releases(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Artist::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 nb_releases = 2;
    if (has_nb_releases()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nb_releases());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Artist::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Artist* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Artist*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Artist::MergeFrom(const AudioCollectionResponse_Artist& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_nb_releases()) {
      set_nb_releases(from.nb_releases());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Artist::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Artist::CopyFrom(const AudioCollectionResponse_Artist& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Artist::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AudioCollectionResponse_Artist::Swap(AudioCollectionResponse_Artist* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(nb_releases_, other->nb_releases_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Artist::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Artist_descriptor_;
  metadata.reflection = AudioCollectionResponse_Artist_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Release::kNameFieldNumber;
const int AudioCollectionResponse_Release::kNbTracksFieldNumber;
const int AudioCollectionResponse_Release::kDurationSecsFieldNumber;
const int AudioCollectionResponse_Release::kCoverArtFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Release::AudioCollectionResponse_Release()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Release::InitAsDefaultInstance() {
  coverart_ = const_cast< ::Remote::AudioCollectionResponse_CoverArt*>(&::Remote::AudioCollectionResponse_CoverArt::default_instance());
}

AudioCollectionResponse_Release::AudioCollectionResponse_Release(const AudioCollectionResponse_Release& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Release::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  nb_tracks_ = 0u;
  duration_secs_ = 0u;
  coverart_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Release::~AudioCollectionResponse_Release() {
  SharedDtor();
}

void AudioCollectionResponse_Release::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete coverart_;
  }
}

void AudioCollectionResponse_Release::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Release::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Release_descriptor_;
}

const AudioCollectionResponse_Release& AudioCollectionResponse_Release::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Release* AudioCollectionResponse_Release::default_instance_ = NULL;

AudioCollectionResponse_Release* AudioCollectionResponse_Release::New() const {
  return new AudioCollectionResponse_Release;
}

void AudioCollectionResponse_Release::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    nb_tracks_ = 0u;
    duration_secs_ = 0u;
    if (has_coverart()) {
      if (coverart_ != NULL) coverart_->::Remote::AudioCollectionResponse_CoverArt::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Release::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nb_tracks;
        break;
      }

      // required uint32 nb_tracks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nb_tracks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nb_tracks_)));
          set_has_nb_tracks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_duration_secs;
        break;
      }

      // required uint32 duration_secs = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_secs_)));
          set_has_duration_secs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_coverArt;
        break;
      }

      // optional .Remote.AudioCollectionResponse.CoverArt coverArt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coverArt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_coverart()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Release::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required uint32 nb_tracks = 2;
  if (has_nb_tracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->nb_tracks(), output);
  }

  // required uint32 duration_secs = 3;
  if (has_duration_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->duration_secs(), output);
  }

  // optional .Remote.AudioCollectionResponse.CoverArt coverArt = 4;
  if (has_coverart()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->coverart(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Release::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required uint32 nb_tracks = 2;
  if (has_nb_tracks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->nb_tracks(), target);
  }

  // required uint32 duration_secs = 3;
  if (has_duration_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->duration_secs(), target);
  }

  // optional .Remote.AudioCollectionResponse.CoverArt coverArt = 4;
  if (has_coverart()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->coverart(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Release::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 nb_tracks = 2;
    if (has_nb_tracks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nb_tracks());
    }

    // required uint32 duration_secs = 3;
    if (has_duration_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration_secs());
    }

    // optional .Remote.AudioCollectionResponse.CoverArt coverArt = 4;
    if (has_coverart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coverart());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Release::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Release* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Release*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Release::MergeFrom(const AudioCollectionResponse_Release& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_nb_tracks()) {
      set_nb_tracks(from.nb_tracks());
    }
    if (from.has_duration_secs()) {
      set_duration_secs(from.duration_secs());
    }
    if (from.has_coverart()) {
      mutable_coverart()->::Remote::AudioCollectionResponse_CoverArt::MergeFrom(from.coverart());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Release::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Release::CopyFrom(const AudioCollectionResponse_Release& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Release::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void AudioCollectionResponse_Release::Swap(AudioCollectionResponse_Release* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(nb_tracks_, other->nb_tracks_);
    std::swap(duration_secs_, other->duration_secs_);
    std::swap(coverart_, other->coverart_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Release::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Release_descriptor_;
  metadata.reflection = AudioCollectionResponse_Release_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse_Track::kMediaIdFieldNumber;
const int AudioCollectionResponse_Track::kDiscNumberFieldNumber;
const int AudioCollectionResponse_Track::kTrackNumberFieldNumber;
const int AudioCollectionResponse_Track::kArtistFieldNumber;
const int AudioCollectionResponse_Track::kReleaseFieldNumber;
const int AudioCollectionResponse_Track::kNameFieldNumber;
const int AudioCollectionResponse_Track::kDurationSecsFieldNumber;
const int AudioCollectionResponse_Track::kReleaseDateFieldNumber;
const int AudioCollectionResponse_Track::kOriginalReleaseDateFieldNumber;
const int AudioCollectionResponse_Track::kGenresFieldNumber;
const int AudioCollectionResponse_Track::kCoverArtFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse_Track::AudioCollectionResponse_Track()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse_Track::InitAsDefaultInstance() {
}

AudioCollectionResponse_Track::AudioCollectionResponse_Track(const AudioCollectionResponse_Track& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse_Track::SharedCtor() {
  _cached_size_ = 0;
  media_id_ = GOOGLE_LONGLONG(0);
  disc_number_ = 0u;
  track_number_ = 0u;
  artist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  release_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  duration_secs_ = 0u;
  release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  original_release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  coverart_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse_Track::~AudioCollectionResponse_Track() {
  SharedDtor();
}

void AudioCollectionResponse_Track::SharedDtor() {
  if (artist_ != &::google::protobuf::internal::kEmptyString) {
    delete artist_;
  }
  if (release_ != &::google::protobuf::internal::kEmptyString) {
    delete release_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete release_date_;
  }
  if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete original_release_date_;
  }
  if (coverart_ != &::google::protobuf::internal::kEmptyString) {
    delete coverart_;
  }
  if (this != default_instance_) {
  }
}

void AudioCollectionResponse_Track::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse_Track::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_Track_descriptor_;
}

const AudioCollectionResponse_Track& AudioCollectionResponse_Track::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse_Track* AudioCollectionResponse_Track::default_instance_ = NULL;

AudioCollectionResponse_Track* AudioCollectionResponse_Track::New() const {
  return new AudioCollectionResponse_Track;
}

void AudioCollectionResponse_Track::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    media_id_ = GOOGLE_LONGLONG(0);
    disc_number_ = 0u;
    track_number_ = 0u;
    if (has_artist()) {
      if (artist_ != &::google::protobuf::internal::kEmptyString) {
        artist_->clear();
      }
    }
    if (has_release()) {
      if (release_ != &::google::protobuf::internal::kEmptyString) {
        release_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    duration_secs_ = 0u;
    if (has_release_date()) {
      if (release_date_ != &::google::protobuf::internal::kEmptyString) {
        release_date_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_original_release_date()) {
      if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
        original_release_date_->clear();
      }
    }
    if (has_coverart()) {
      if (coverart_ != &::google::protobuf::internal::kEmptyString) {
        coverart_->clear();
      }
    }
  }
  genres_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse_Track::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 media_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &media_id_)));
          set_has_media_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_disc_number;
        break;
      }

      // optional uint32 disc_number = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_disc_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &disc_number_)));
          set_has_disc_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_track_number;
        break;
      }

      // optional uint32 track_number = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_track_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &track_number_)));
          set_has_track_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_artist;
        break;
      }

      // optional string artist = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_artist()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist().data(), this->artist().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_release;
        break;
      }

      // optional string release = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_release()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release().data(), this->release().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_name;
        break;
      }

      // required string name = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_duration_secs;
        break;
      }

      // required uint32 duration_secs = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_duration_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_secs_)));
          set_has_duration_secs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_release_date;
        break;
      }

      // optional string release_date = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_release_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->release_date().data(), this->release_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_original_release_date;
        break;
      }

      // optional string original_release_date = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_original_release_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_original_release_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->original_release_date().data(), this->original_release_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_genres;
        break;
      }

      // repeated string genres = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genres:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_genres()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->genres(this->genres_size() - 1).data(),
            this->genres(this->genres_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_genres;
        if (input->ExpectTag(90)) goto parse_coverArt;
        break;
      }

      // optional bytes coverArt = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coverArt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_coverart()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse_Track::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 media_id = 1;
  if (has_media_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->media_id(), output);
  }

  // optional uint32 disc_number = 2;
  if (has_disc_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->disc_number(), output);
  }

  // optional uint32 track_number = 3;
  if (has_track_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->track_number(), output);
  }

  // optional string artist = 4;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->artist(), output);
  }

  // optional string release = 5;
  if (has_release()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release().data(), this->release().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->release(), output);
  }

  // required string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->name(), output);
  }

  // required uint32 duration_secs = 7;
  if (has_duration_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->duration_secs(), output);
  }

  // optional string release_date = 8;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->release_date(), output);
  }

  // optional string original_release_date = 9;
  if (has_original_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->original_release_date().data(), this->original_release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->original_release_date(), output);
  }

  // repeated string genres = 10;
  for (int i = 0; i < this->genres_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->genres(i).data(), this->genres(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->genres(i), output);
  }

  // optional bytes coverArt = 11;
  if (has_coverart()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      11, this->coverart(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse_Track::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 media_id = 1;
  if (has_media_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->media_id(), target);
  }

  // optional uint32 disc_number = 2;
  if (has_disc_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->disc_number(), target);
  }

  // optional uint32 track_number = 3;
  if (has_track_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->track_number(), target);
  }

  // optional string artist = 4;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->artist(), target);
  }

  // optional string release = 5;
  if (has_release()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release().data(), this->release().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->release(), target);
  }

  // required string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->name(), target);
  }

  // required uint32 duration_secs = 7;
  if (has_duration_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->duration_secs(), target);
  }

  // optional string release_date = 8;
  if (has_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->release_date().data(), this->release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->release_date(), target);
  }

  // optional string original_release_date = 9;
  if (has_original_release_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->original_release_date().data(), this->original_release_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->original_release_date(), target);
  }

  // repeated string genres = 10;
  for (int i = 0; i < this->genres_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->genres(i).data(), this->genres(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(10, this->genres(i), target);
  }

  // optional bytes coverArt = 11;
  if (has_coverart()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->coverart(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse_Track::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 media_id = 1;
    if (has_media_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->media_id());
    }

    // optional uint32 disc_number = 2;
    if (has_disc_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->disc_number());
    }

    // optional uint32 track_number = 3;
    if (has_track_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->track_number());
    }

    // optional string artist = 4;
    if (has_artist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->artist());
    }

    // optional string release = 5;
    if (has_release()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->release());
    }

    // required string name = 6;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required uint32 duration_secs = 7;
    if (has_duration_secs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration_secs());
    }

    // optional string release_date = 8;
    if (has_release_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->release_date());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string original_release_date = 9;
    if (has_original_release_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->original_release_date());
    }

    // optional bytes coverArt = 11;
    if (has_coverart()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->coverart());
    }

  }
  // repeated string genres = 10;
  total_size += 1 * this->genres_size();
  for (int i = 0; i < this->genres_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->genres(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse_Track::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse_Track* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse_Track*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse_Track::MergeFrom(const AudioCollectionResponse_Track& from) {
  GOOGLE_CHECK_NE(&from, this);
  genres_.MergeFrom(from.genres_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_media_id()) {
      set_media_id(from.media_id());
    }
    if (from.has_disc_number()) {
      set_disc_number(from.disc_number());
    }
    if (from.has_track_number()) {
      set_track_number(from.track_number());
    }
    if (from.has_artist()) {
      set_artist(from.artist());
    }
    if (from.has_release()) {
      set_release(from.release());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_duration_secs()) {
      set_duration_secs(from.duration_secs());
    }
    if (from.has_release_date()) {
      set_release_date(from.release_date());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_original_release_date()) {
      set_original_release_date(from.original_release_date());
    }
    if (from.has_coverart()) {
      set_coverart(from.coverart());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse_Track::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse_Track::CopyFrom(const AudioCollectionResponse_Track& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse_Track::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000061) != 0x00000061) return false;

  return true;
}

void AudioCollectionResponse_Track::Swap(AudioCollectionResponse_Track* other) {
  if (other != this) {
    std::swap(media_id_, other->media_id_);
    std::swap(disc_number_, other->disc_number_);
    std::swap(track_number_, other->track_number_);
    std::swap(artist_, other->artist_);
    std::swap(release_, other->release_);
    std::swap(name_, other->name_);
    std::swap(duration_secs_, other->duration_secs_);
    std::swap(release_date_, other->release_date_);
    std::swap(original_release_date_, other->original_release_date_);
    genres_.Swap(&other->genres_);
    std::swap(coverart_, other->coverart_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse_Track::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_Track_descriptor_;
  metadata.reflection = AudioCollectionResponse_Track_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int AudioCollectionResponse::kTypeFieldNumber;
const int AudioCollectionResponse::kErrorFieldNumber;
const int AudioCollectionResponse::kGenreListFieldNumber;
const int AudioCollectionResponse::kArtistListFieldNumber;
const int AudioCollectionResponse::kReleaseListFieldNumber;
const int AudioCollectionResponse::kTrackListFieldNumber;
#endif  // !_MSC_VER

AudioCollectionResponse::AudioCollectionResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AudioCollectionResponse::InitAsDefaultInstance() {
  error_ = const_cast< ::Remote::Error*>(&::Remote::Error::default_instance());
  genre_list_ = const_cast< ::Remote::AudioCollectionResponse_GenreList*>(&::Remote::AudioCollectionResponse_GenreList::default_instance());
  artist_list_ = const_cast< ::Remote::AudioCollectionResponse_ArtistList*>(&::Remote::AudioCollectionResponse_ArtistList::default_instance());
  release_list_ = const_cast< ::Remote::AudioCollectionResponse_ReleaseList*>(&::Remote::AudioCollectionResponse_ReleaseList::default_instance());
  track_list_ = const_cast< ::Remote::AudioCollectionResponse_TrackList*>(&::Remote::AudioCollectionResponse_TrackList::default_instance());
}

AudioCollectionResponse::AudioCollectionResponse(const AudioCollectionResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AudioCollectionResponse::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  error_ = NULL;
  genre_list_ = NULL;
  artist_list_ = NULL;
  release_list_ = NULL;
  track_list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AudioCollectionResponse::~AudioCollectionResponse() {
  SharedDtor();
}

void AudioCollectionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete error_;
    delete genre_list_;
    delete artist_list_;
    delete release_list_;
    delete track_list_;
  }
}

void AudioCollectionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AudioCollectionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AudioCollectionResponse_descriptor_;
}

const AudioCollectionResponse& AudioCollectionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_collection_2eproto();
  return *default_instance_;
}

AudioCollectionResponse* AudioCollectionResponse::default_instance_ = NULL;

AudioCollectionResponse* AudioCollectionResponse::New() const {
  return new AudioCollectionResponse;
}

void AudioCollectionResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_error()) {
      if (error_ != NULL) error_->::Remote::Error::Clear();
    }
    if (has_genre_list()) {
      if (genre_list_ != NULL) genre_list_->::Remote::AudioCollectionResponse_GenreList::Clear();
    }
    if (has_artist_list()) {
      if (artist_list_ != NULL) artist_list_->::Remote::AudioCollectionResponse_ArtistList::Clear();
    }
    if (has_release_list()) {
      if (release_list_ != NULL) release_list_->::Remote::AudioCollectionResponse_ReleaseList::Clear();
    }
    if (has_track_list()) {
      if (track_list_ != NULL) track_list_->::Remote::AudioCollectionResponse_TrackList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AudioCollectionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Remote.AudioCollectionResponse.Type type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Remote::AudioCollectionResponse_Type_IsValid(value)) {
            set_type(static_cast< ::Remote::AudioCollectionResponse_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_error;
        break;
      }

      // optional .Remote.Error error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_genre_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.GenreList genre_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_genre_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_genre_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_artist_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_artist_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_release_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_release_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_release_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_track_list;
        break;
      }

      // optional .Remote.AudioCollectionResponse.TrackList track_list = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_track_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_track_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AudioCollectionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Remote.AudioCollectionResponse.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .Remote.Error error = 2;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->error(), output);
  }

  // optional .Remote.AudioCollectionResponse.GenreList genre_list = 3;
  if (has_genre_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->genre_list(), output);
  }

  // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 4;
  if (has_artist_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->artist_list(), output);
  }

  // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 5;
  if (has_release_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->release_list(), output);
  }

  // optional .Remote.AudioCollectionResponse.TrackList track_list = 6;
  if (has_track_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->track_list(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AudioCollectionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Remote.AudioCollectionResponse.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .Remote.Error error = 2;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->error(), target);
  }

  // optional .Remote.AudioCollectionResponse.GenreList genre_list = 3;
  if (has_genre_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->genre_list(), target);
  }

  // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 4;
  if (has_artist_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->artist_list(), target);
  }

  // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 5;
  if (has_release_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->release_list(), target);
  }

  // optional .Remote.AudioCollectionResponse.TrackList track_list = 6;
  if (has_track_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->track_list(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AudioCollectionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Remote.AudioCollectionResponse.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Remote.Error error = 2;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->error());
    }

    // optional .Remote.AudioCollectionResponse.GenreList genre_list = 3;
    if (has_genre_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->genre_list());
    }

    // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 4;
    if (has_artist_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->artist_list());
    }

    // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 5;
    if (has_release_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->release_list());
    }

    // optional .Remote.AudioCollectionResponse.TrackList track_list = 6;
    if (has_track_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->track_list());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AudioCollectionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AudioCollectionResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AudioCollectionResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AudioCollectionResponse::MergeFrom(const AudioCollectionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_error()) {
      mutable_error()->::Remote::Error::MergeFrom(from.error());
    }
    if (from.has_genre_list()) {
      mutable_genre_list()->::Remote::AudioCollectionResponse_GenreList::MergeFrom(from.genre_list());
    }
    if (from.has_artist_list()) {
      mutable_artist_list()->::Remote::AudioCollectionResponse_ArtistList::MergeFrom(from.artist_list());
    }
    if (from.has_release_list()) {
      mutable_release_list()->::Remote::AudioCollectionResponse_ReleaseList::MergeFrom(from.release_list());
    }
    if (from.has_track_list()) {
      mutable_track_list()->::Remote::AudioCollectionResponse_TrackList::MergeFrom(from.track_list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AudioCollectionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AudioCollectionResponse::CopyFrom(const AudioCollectionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioCollectionResponse::IsInitialized() const {

  if (has_error()) {
    if (!this->error().IsInitialized()) return false;
  }
  if (has_genre_list()) {
    if (!this->genre_list().IsInitialized()) return false;
  }
  if (has_artist_list()) {
    if (!this->artist_list().IsInitialized()) return false;
  }
  if (has_release_list()) {
    if (!this->release_list().IsInitialized()) return false;
  }
  if (has_track_list()) {
    if (!this->track_list().IsInitialized()) return false;
  }
  return true;
}

void AudioCollectionResponse::Swap(AudioCollectionResponse* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(error_, other->error_);
    std::swap(genre_list_, other->genre_list_);
    std::swap(artist_list_, other->artist_list_);
    std::swap(release_list_, other->release_list_);
    std::swap(track_list_, other->track_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AudioCollectionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AudioCollectionResponse_descriptor_;
  metadata.reflection = AudioCollectionResponse_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Remote

// @@protoc_insertion_point(global_scope)
