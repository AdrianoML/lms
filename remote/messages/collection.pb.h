// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collection.proto

#ifndef PROTOBUF_collection_2eproto__INCLUDED
#define PROTOBUF_collection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace Remote {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_collection_2eproto();
void protobuf_AssignDesc_collection_2eproto();
void protobuf_ShutdownFile_collection_2eproto();

class AudioCollectionRequest;
class AudioCollectionRequest_BatchParameter;
class AudioCollectionRequest_GetGenreList;
class AudioCollectionRequest_GetArtistList;
class AudioCollectionRequest_GetReleaseList;
class AudioCollectionRequest_GetTrackList;
class AudioCollectionRequest_GetCoverArt;
class AudioCollectionResponse;
class AudioCollectionResponse_Revision;
class AudioCollectionResponse_GenreList;
class AudioCollectionResponse_ArtistList;
class AudioCollectionResponse_ReleaseList;
class AudioCollectionResponse_TrackList;
class AudioCollectionResponse_CoverArt;
class AudioCollectionResponse_Genre;
class AudioCollectionResponse_Artist;
class AudioCollectionResponse_Release;
class AudioCollectionResponse_Track;

enum AudioCollectionRequest_GetCoverArt_Type {
  AudioCollectionRequest_GetCoverArt_Type_TypeGetCoverArtRelease = 1,
  AudioCollectionRequest_GetCoverArt_Type_TypeGetCoverArtTrack = 2
};
bool AudioCollectionRequest_GetCoverArt_Type_IsValid(int value);
const AudioCollectionRequest_GetCoverArt_Type AudioCollectionRequest_GetCoverArt_Type_Type_MIN = AudioCollectionRequest_GetCoverArt_Type_TypeGetCoverArtRelease;
const AudioCollectionRequest_GetCoverArt_Type AudioCollectionRequest_GetCoverArt_Type_Type_MAX = AudioCollectionRequest_GetCoverArt_Type_TypeGetCoverArtTrack;
const int AudioCollectionRequest_GetCoverArt_Type_Type_ARRAYSIZE = AudioCollectionRequest_GetCoverArt_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_GetCoverArt_Type_descriptor();
inline const ::std::string& AudioCollectionRequest_GetCoverArt_Type_Name(AudioCollectionRequest_GetCoverArt_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioCollectionRequest_GetCoverArt_Type_descriptor(), value);
}
inline bool AudioCollectionRequest_GetCoverArt_Type_Parse(
    const ::std::string& name, AudioCollectionRequest_GetCoverArt_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioCollectionRequest_GetCoverArt_Type>(
    AudioCollectionRequest_GetCoverArt_Type_descriptor(), name, value);
}
enum AudioCollectionRequest_Type {
  AudioCollectionRequest_Type_TypeGetRevision = 1,
  AudioCollectionRequest_Type_TypeGetGenreList = 2,
  AudioCollectionRequest_Type_TypeGetArtistList = 3,
  AudioCollectionRequest_Type_TypeGetReleaseList = 4,
  AudioCollectionRequest_Type_TypeGetTrackList = 5,
  AudioCollectionRequest_Type_TypeGetCoverArt = 6
};
bool AudioCollectionRequest_Type_IsValid(int value);
const AudioCollectionRequest_Type AudioCollectionRequest_Type_Type_MIN = AudioCollectionRequest_Type_TypeGetRevision;
const AudioCollectionRequest_Type AudioCollectionRequest_Type_Type_MAX = AudioCollectionRequest_Type_TypeGetCoverArt;
const int AudioCollectionRequest_Type_Type_ARRAYSIZE = AudioCollectionRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioCollectionRequest_Type_descriptor();
inline const ::std::string& AudioCollectionRequest_Type_Name(AudioCollectionRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioCollectionRequest_Type_descriptor(), value);
}
inline bool AudioCollectionRequest_Type_Parse(
    const ::std::string& name, AudioCollectionRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioCollectionRequest_Type>(
    AudioCollectionRequest_Type_descriptor(), name, value);
}
enum AudioCollectionResponse_Type {
  AudioCollectionResponse_Type_TypeRevision = 1,
  AudioCollectionResponse_Type_TypeGenreList = 2,
  AudioCollectionResponse_Type_TypeArtistList = 3,
  AudioCollectionResponse_Type_TypeReleaseList = 4,
  AudioCollectionResponse_Type_TypeTrackList = 5,
  AudioCollectionResponse_Type_TypeCoverArt = 6
};
bool AudioCollectionResponse_Type_IsValid(int value);
const AudioCollectionResponse_Type AudioCollectionResponse_Type_Type_MIN = AudioCollectionResponse_Type_TypeRevision;
const AudioCollectionResponse_Type AudioCollectionResponse_Type_Type_MAX = AudioCollectionResponse_Type_TypeCoverArt;
const int AudioCollectionResponse_Type_Type_ARRAYSIZE = AudioCollectionResponse_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AudioCollectionResponse_Type_descriptor();
inline const ::std::string& AudioCollectionResponse_Type_Name(AudioCollectionResponse_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AudioCollectionResponse_Type_descriptor(), value);
}
inline bool AudioCollectionResponse_Type_Parse(
    const ::std::string& name, AudioCollectionResponse_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AudioCollectionResponse_Type>(
    AudioCollectionResponse_Type_descriptor(), name, value);
}
// ===================================================================

class AudioCollectionRequest_BatchParameter : public ::google::protobuf::Message {
 public:
  AudioCollectionRequest_BatchParameter();
  virtual ~AudioCollectionRequest_BatchParameter();

  AudioCollectionRequest_BatchParameter(const AudioCollectionRequest_BatchParameter& from);

  inline AudioCollectionRequest_BatchParameter& operator=(const AudioCollectionRequest_BatchParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionRequest_BatchParameter& default_instance();

  void Swap(AudioCollectionRequest_BatchParameter* other);

  // implements Message ----------------------------------------------

  AudioCollectionRequest_BatchParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionRequest_BatchParameter& from);
  void MergeFrom(const AudioCollectionRequest_BatchParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required uint32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionRequest.BatchParameter)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionRequest_BatchParameter* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionRequest_GetGenreList : public ::google::protobuf::Message {
 public:
  AudioCollectionRequest_GetGenreList();
  virtual ~AudioCollectionRequest_GetGenreList();

  AudioCollectionRequest_GetGenreList(const AudioCollectionRequest_GetGenreList& from);

  inline AudioCollectionRequest_GetGenreList& operator=(const AudioCollectionRequest_GetGenreList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionRequest_GetGenreList& default_instance();

  void Swap(AudioCollectionRequest_GetGenreList* other);

  // implements Message ----------------------------------------------

  AudioCollectionRequest_GetGenreList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionRequest_GetGenreList& from);
  void MergeFrom(const AudioCollectionRequest_GetGenreList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  inline bool has_batch_parameter() const;
  inline void clear_batch_parameter();
  static const int kBatchParameterFieldNumber = 1;
  inline const ::Remote::AudioCollectionRequest_BatchParameter& batch_parameter() const;
  inline ::Remote::AudioCollectionRequest_BatchParameter* mutable_batch_parameter();
  inline ::Remote::AudioCollectionRequest_BatchParameter* release_batch_parameter();
  inline void set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionRequest.GetGenreList)
 private:
  inline void set_has_batch_parameter();
  inline void clear_has_batch_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Remote::AudioCollectionRequest_BatchParameter* batch_parameter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionRequest_GetGenreList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionRequest_GetArtistList : public ::google::protobuf::Message {
 public:
  AudioCollectionRequest_GetArtistList();
  virtual ~AudioCollectionRequest_GetArtistList();

  AudioCollectionRequest_GetArtistList(const AudioCollectionRequest_GetArtistList& from);

  inline AudioCollectionRequest_GetArtistList& operator=(const AudioCollectionRequest_GetArtistList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionRequest_GetArtistList& default_instance();

  void Swap(AudioCollectionRequest_GetArtistList* other);

  // implements Message ----------------------------------------------

  AudioCollectionRequest_GetArtistList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionRequest_GetArtistList& from);
  void MergeFrom(const AudioCollectionRequest_GetArtistList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  inline bool has_batch_parameter() const;
  inline void clear_batch_parameter();
  static const int kBatchParameterFieldNumber = 1;
  inline const ::Remote::AudioCollectionRequest_BatchParameter& batch_parameter() const;
  inline ::Remote::AudioCollectionRequest_BatchParameter* mutable_batch_parameter();
  inline ::Remote::AudioCollectionRequest_BatchParameter* release_batch_parameter();
  inline void set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter);

  // repeated uint64 genre_id = 2;
  inline int genre_id_size() const;
  inline void clear_genre_id();
  static const int kGenreIdFieldNumber = 2;
  inline ::google::protobuf::uint64 genre_id(int index) const;
  inline void set_genre_id(int index, ::google::protobuf::uint64 value);
  inline void add_genre_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      genre_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_genre_id();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionRequest.GetArtistList)
 private:
  inline void set_has_batch_parameter();
  inline void clear_has_batch_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Remote::AudioCollectionRequest_BatchParameter* batch_parameter_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > genre_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionRequest_GetArtistList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionRequest_GetReleaseList : public ::google::protobuf::Message {
 public:
  AudioCollectionRequest_GetReleaseList();
  virtual ~AudioCollectionRequest_GetReleaseList();

  AudioCollectionRequest_GetReleaseList(const AudioCollectionRequest_GetReleaseList& from);

  inline AudioCollectionRequest_GetReleaseList& operator=(const AudioCollectionRequest_GetReleaseList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionRequest_GetReleaseList& default_instance();

  void Swap(AudioCollectionRequest_GetReleaseList* other);

  // implements Message ----------------------------------------------

  AudioCollectionRequest_GetReleaseList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionRequest_GetReleaseList& from);
  void MergeFrom(const AudioCollectionRequest_GetReleaseList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  inline bool has_batch_parameter() const;
  inline void clear_batch_parameter();
  static const int kBatchParameterFieldNumber = 1;
  inline const ::Remote::AudioCollectionRequest_BatchParameter& batch_parameter() const;
  inline ::Remote::AudioCollectionRequest_BatchParameter* mutable_batch_parameter();
  inline ::Remote::AudioCollectionRequest_BatchParameter* release_batch_parameter();
  inline void set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter);

  // repeated uint64 artist_id = 2;
  inline int artist_id_size() const;
  inline void clear_artist_id();
  static const int kArtistIdFieldNumber = 2;
  inline ::google::protobuf::uint64 artist_id(int index) const;
  inline void set_artist_id(int index, ::google::protobuf::uint64 value);
  inline void add_artist_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      artist_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_artist_id();

  // repeated uint64 filter_genre = 3;
  inline int filter_genre_size() const;
  inline void clear_filter_genre();
  static const int kFilterGenreFieldNumber = 3;
  inline ::google::protobuf::uint64 filter_genre(int index) const;
  inline void set_filter_genre(int index, ::google::protobuf::uint64 value);
  inline void add_filter_genre(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      filter_genre() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_filter_genre();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionRequest.GetReleaseList)
 private:
  inline void set_has_batch_parameter();
  inline void clear_has_batch_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Remote::AudioCollectionRequest_BatchParameter* batch_parameter_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > artist_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > filter_genre_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionRequest_GetReleaseList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionRequest_GetTrackList : public ::google::protobuf::Message {
 public:
  AudioCollectionRequest_GetTrackList();
  virtual ~AudioCollectionRequest_GetTrackList();

  AudioCollectionRequest_GetTrackList(const AudioCollectionRequest_GetTrackList& from);

  inline AudioCollectionRequest_GetTrackList& operator=(const AudioCollectionRequest_GetTrackList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionRequest_GetTrackList& default_instance();

  void Swap(AudioCollectionRequest_GetTrackList* other);

  // implements Message ----------------------------------------------

  AudioCollectionRequest_GetTrackList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionRequest_GetTrackList& from);
  void MergeFrom(const AudioCollectionRequest_GetTrackList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
  inline bool has_batch_parameter() const;
  inline void clear_batch_parameter();
  static const int kBatchParameterFieldNumber = 1;
  inline const ::Remote::AudioCollectionRequest_BatchParameter& batch_parameter() const;
  inline ::Remote::AudioCollectionRequest_BatchParameter* mutable_batch_parameter();
  inline ::Remote::AudioCollectionRequest_BatchParameter* release_batch_parameter();
  inline void set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter);

  // repeated uint64 artist_id = 2;
  inline int artist_id_size() const;
  inline void clear_artist_id();
  static const int kArtistIdFieldNumber = 2;
  inline ::google::protobuf::uint64 artist_id(int index) const;
  inline void set_artist_id(int index, ::google::protobuf::uint64 value);
  inline void add_artist_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      artist_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_artist_id();

  // repeated uint64 release_id = 3;
  inline int release_id_size() const;
  inline void clear_release_id();
  static const int kReleaseIdFieldNumber = 3;
  inline ::google::protobuf::uint64 release_id(int index) const;
  inline void set_release_id(int index, ::google::protobuf::uint64 value);
  inline void add_release_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      release_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_release_id();

  // repeated uint64 genre_id = 4;
  inline int genre_id_size() const;
  inline void clear_genre_id();
  static const int kGenreIdFieldNumber = 4;
  inline ::google::protobuf::uint64 genre_id(int index) const;
  inline void set_genre_id(int index, ::google::protobuf::uint64 value);
  inline void add_genre_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      genre_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_genre_id();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionRequest.GetTrackList)
 private:
  inline void set_has_batch_parameter();
  inline void clear_has_batch_parameter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Remote::AudioCollectionRequest_BatchParameter* batch_parameter_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > artist_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > release_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > genre_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionRequest_GetTrackList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionRequest_GetCoverArt : public ::google::protobuf::Message {
 public:
  AudioCollectionRequest_GetCoverArt();
  virtual ~AudioCollectionRequest_GetCoverArt();

  AudioCollectionRequest_GetCoverArt(const AudioCollectionRequest_GetCoverArt& from);

  inline AudioCollectionRequest_GetCoverArt& operator=(const AudioCollectionRequest_GetCoverArt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionRequest_GetCoverArt& default_instance();

  void Swap(AudioCollectionRequest_GetCoverArt* other);

  // implements Message ----------------------------------------------

  AudioCollectionRequest_GetCoverArt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionRequest_GetCoverArt& from);
  void MergeFrom(const AudioCollectionRequest_GetCoverArt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AudioCollectionRequest_GetCoverArt_Type Type;
  static const Type TypeGetCoverArtRelease = AudioCollectionRequest_GetCoverArt_Type_TypeGetCoverArtRelease;
  static const Type TypeGetCoverArtTrack = AudioCollectionRequest_GetCoverArt_Type_TypeGetCoverArtTrack;
  static inline bool Type_IsValid(int value) {
    return AudioCollectionRequest_GetCoverArt_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AudioCollectionRequest_GetCoverArt_Type_Type_MIN;
  static const Type Type_MAX =
    AudioCollectionRequest_GetCoverArt_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AudioCollectionRequest_GetCoverArt_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AudioCollectionRequest_GetCoverArt_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AudioCollectionRequest_GetCoverArt_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AudioCollectionRequest_GetCoverArt_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Remote.AudioCollectionRequest.GetCoverArt.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Remote::AudioCollectionRequest_GetCoverArt_Type type() const;
  inline void set_type(::Remote::AudioCollectionRequest_GetCoverArt_Type value);

  // optional uint64 release_id = 2;
  inline bool has_release_id() const;
  inline void clear_release_id();
  static const int kReleaseIdFieldNumber = 2;
  inline ::google::protobuf::uint64 release_id() const;
  inline void set_release_id(::google::protobuf::uint64 value);

  // optional uint64 track_id = 3;
  inline bool has_track_id() const;
  inline void clear_track_id();
  static const int kTrackIdFieldNumber = 3;
  inline ::google::protobuf::uint64 track_id() const;
  inline void set_track_id(::google::protobuf::uint64 value);

  // required uint32 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionRequest.GetCoverArt)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_release_id();
  inline void clear_has_release_id();
  inline void set_has_track_id();
  inline void clear_has_track_id();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 release_id_;
  int type_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::uint64 track_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionRequest_GetCoverArt* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionRequest : public ::google::protobuf::Message {
 public:
  AudioCollectionRequest();
  virtual ~AudioCollectionRequest();

  AudioCollectionRequest(const AudioCollectionRequest& from);

  inline AudioCollectionRequest& operator=(const AudioCollectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionRequest& default_instance();

  void Swap(AudioCollectionRequest* other);

  // implements Message ----------------------------------------------

  AudioCollectionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionRequest& from);
  void MergeFrom(const AudioCollectionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AudioCollectionRequest_BatchParameter BatchParameter;
  typedef AudioCollectionRequest_GetGenreList GetGenreList;
  typedef AudioCollectionRequest_GetArtistList GetArtistList;
  typedef AudioCollectionRequest_GetReleaseList GetReleaseList;
  typedef AudioCollectionRequest_GetTrackList GetTrackList;
  typedef AudioCollectionRequest_GetCoverArt GetCoverArt;

  typedef AudioCollectionRequest_Type Type;
  static const Type TypeGetRevision = AudioCollectionRequest_Type_TypeGetRevision;
  static const Type TypeGetGenreList = AudioCollectionRequest_Type_TypeGetGenreList;
  static const Type TypeGetArtistList = AudioCollectionRequest_Type_TypeGetArtistList;
  static const Type TypeGetReleaseList = AudioCollectionRequest_Type_TypeGetReleaseList;
  static const Type TypeGetTrackList = AudioCollectionRequest_Type_TypeGetTrackList;
  static const Type TypeGetCoverArt = AudioCollectionRequest_Type_TypeGetCoverArt;
  static inline bool Type_IsValid(int value) {
    return AudioCollectionRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AudioCollectionRequest_Type_Type_MIN;
  static const Type Type_MAX =
    AudioCollectionRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AudioCollectionRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AudioCollectionRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AudioCollectionRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AudioCollectionRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Remote.AudioCollectionRequest.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Remote::AudioCollectionRequest_Type type() const;
  inline void set_type(::Remote::AudioCollectionRequest_Type value);

  // optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
  inline bool has_get_genres() const;
  inline void clear_get_genres();
  static const int kGetGenresFieldNumber = 2;
  inline const ::Remote::AudioCollectionRequest_GetGenreList& get_genres() const;
  inline ::Remote::AudioCollectionRequest_GetGenreList* mutable_get_genres();
  inline ::Remote::AudioCollectionRequest_GetGenreList* release_get_genres();
  inline void set_allocated_get_genres(::Remote::AudioCollectionRequest_GetGenreList* get_genres);

  // optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
  inline bool has_get_artists() const;
  inline void clear_get_artists();
  static const int kGetArtistsFieldNumber = 3;
  inline const ::Remote::AudioCollectionRequest_GetArtistList& get_artists() const;
  inline ::Remote::AudioCollectionRequest_GetArtistList* mutable_get_artists();
  inline ::Remote::AudioCollectionRequest_GetArtistList* release_get_artists();
  inline void set_allocated_get_artists(::Remote::AudioCollectionRequest_GetArtistList* get_artists);

  // optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
  inline bool has_get_releases() const;
  inline void clear_get_releases();
  static const int kGetReleasesFieldNumber = 4;
  inline const ::Remote::AudioCollectionRequest_GetReleaseList& get_releases() const;
  inline ::Remote::AudioCollectionRequest_GetReleaseList* mutable_get_releases();
  inline ::Remote::AudioCollectionRequest_GetReleaseList* release_get_releases();
  inline void set_allocated_get_releases(::Remote::AudioCollectionRequest_GetReleaseList* get_releases);

  // optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
  inline bool has_get_tracks() const;
  inline void clear_get_tracks();
  static const int kGetTracksFieldNumber = 5;
  inline const ::Remote::AudioCollectionRequest_GetTrackList& get_tracks() const;
  inline ::Remote::AudioCollectionRequest_GetTrackList* mutable_get_tracks();
  inline ::Remote::AudioCollectionRequest_GetTrackList* release_get_tracks();
  inline void set_allocated_get_tracks(::Remote::AudioCollectionRequest_GetTrackList* get_tracks);

  // optional .Remote.AudioCollectionRequest.GetCoverArt get_cover_art = 6;
  inline bool has_get_cover_art() const;
  inline void clear_get_cover_art();
  static const int kGetCoverArtFieldNumber = 6;
  inline const ::Remote::AudioCollectionRequest_GetCoverArt& get_cover_art() const;
  inline ::Remote::AudioCollectionRequest_GetCoverArt* mutable_get_cover_art();
  inline ::Remote::AudioCollectionRequest_GetCoverArt* release_get_cover_art();
  inline void set_allocated_get_cover_art(::Remote::AudioCollectionRequest_GetCoverArt* get_cover_art);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_get_genres();
  inline void clear_has_get_genres();
  inline void set_has_get_artists();
  inline void clear_has_get_artists();
  inline void set_has_get_releases();
  inline void clear_has_get_releases();
  inline void set_has_get_tracks();
  inline void clear_has_get_tracks();
  inline void set_has_get_cover_art();
  inline void clear_has_get_cover_art();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Remote::AudioCollectionRequest_GetGenreList* get_genres_;
  ::Remote::AudioCollectionRequest_GetArtistList* get_artists_;
  ::Remote::AudioCollectionRequest_GetReleaseList* get_releases_;
  ::Remote::AudioCollectionRequest_GetTrackList* get_tracks_;
  ::Remote::AudioCollectionRequest_GetCoverArt* get_cover_art_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_Revision : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_Revision();
  virtual ~AudioCollectionResponse_Revision();

  AudioCollectionResponse_Revision(const AudioCollectionResponse_Revision& from);

  inline AudioCollectionResponse_Revision& operator=(const AudioCollectionResponse_Revision& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_Revision& default_instance();

  void Swap(AudioCollectionResponse_Revision* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_Revision* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_Revision& from);
  void MergeFrom(const AudioCollectionResponse_Revision& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 rev = 1;
  inline bool has_rev() const;
  inline void clear_rev();
  static const int kRevFieldNumber = 1;
  inline ::google::protobuf::uint64 rev() const;
  inline void set_rev(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.Revision)
 private:
  inline void set_has_rev();
  inline void clear_has_rev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 rev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_Revision* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_GenreList : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_GenreList();
  virtual ~AudioCollectionResponse_GenreList();

  AudioCollectionResponse_GenreList(const AudioCollectionResponse_GenreList& from);

  inline AudioCollectionResponse_GenreList& operator=(const AudioCollectionResponse_GenreList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_GenreList& default_instance();

  void Swap(AudioCollectionResponse_GenreList* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_GenreList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_GenreList& from);
  void MergeFrom(const AudioCollectionResponse_GenreList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Remote.AudioCollectionResponse.Genre genres = 2;
  inline int genres_size() const;
  inline void clear_genres();
  static const int kGenresFieldNumber = 2;
  inline const ::Remote::AudioCollectionResponse_Genre& genres(int index) const;
  inline ::Remote::AudioCollectionResponse_Genre* mutable_genres(int index);
  inline ::Remote::AudioCollectionResponse_Genre* add_genres();
  inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Genre >&
      genres() const;
  inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Genre >*
      mutable_genres();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.GenreList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Genre > genres_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_GenreList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_ArtistList : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_ArtistList();
  virtual ~AudioCollectionResponse_ArtistList();

  AudioCollectionResponse_ArtistList(const AudioCollectionResponse_ArtistList& from);

  inline AudioCollectionResponse_ArtistList& operator=(const AudioCollectionResponse_ArtistList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_ArtistList& default_instance();

  void Swap(AudioCollectionResponse_ArtistList* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_ArtistList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_ArtistList& from);
  void MergeFrom(const AudioCollectionResponse_ArtistList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Remote.AudioCollectionResponse.Artist artists = 2;
  inline int artists_size() const;
  inline void clear_artists();
  static const int kArtistsFieldNumber = 2;
  inline const ::Remote::AudioCollectionResponse_Artist& artists(int index) const;
  inline ::Remote::AudioCollectionResponse_Artist* mutable_artists(int index);
  inline ::Remote::AudioCollectionResponse_Artist* add_artists();
  inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Artist >&
      artists() const;
  inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Artist >*
      mutable_artists();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.ArtistList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Artist > artists_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_ArtistList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_ReleaseList : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_ReleaseList();
  virtual ~AudioCollectionResponse_ReleaseList();

  AudioCollectionResponse_ReleaseList(const AudioCollectionResponse_ReleaseList& from);

  inline AudioCollectionResponse_ReleaseList& operator=(const AudioCollectionResponse_ReleaseList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_ReleaseList& default_instance();

  void Swap(AudioCollectionResponse_ReleaseList* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_ReleaseList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_ReleaseList& from);
  void MergeFrom(const AudioCollectionResponse_ReleaseList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Remote.AudioCollectionResponse.Release releases = 2;
  inline int releases_size() const;
  inline void clear_releases();
  static const int kReleasesFieldNumber = 2;
  inline const ::Remote::AudioCollectionResponse_Release& releases(int index) const;
  inline ::Remote::AudioCollectionResponse_Release* mutable_releases(int index);
  inline ::Remote::AudioCollectionResponse_Release* add_releases();
  inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Release >&
      releases() const;
  inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Release >*
      mutable_releases();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.ReleaseList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Release > releases_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_ReleaseList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_TrackList : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_TrackList();
  virtual ~AudioCollectionResponse_TrackList();

  AudioCollectionResponse_TrackList(const AudioCollectionResponse_TrackList& from);

  inline AudioCollectionResponse_TrackList& operator=(const AudioCollectionResponse_TrackList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_TrackList& default_instance();

  void Swap(AudioCollectionResponse_TrackList* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_TrackList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_TrackList& from);
  void MergeFrom(const AudioCollectionResponse_TrackList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Remote.AudioCollectionResponse.Track tracks = 2;
  inline int tracks_size() const;
  inline void clear_tracks();
  static const int kTracksFieldNumber = 2;
  inline const ::Remote::AudioCollectionResponse_Track& tracks(int index) const;
  inline ::Remote::AudioCollectionResponse_Track* mutable_tracks(int index);
  inline ::Remote::AudioCollectionResponse_Track* add_tracks();
  inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Track >&
      tracks() const;
  inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Track >*
      mutable_tracks();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.TrackList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Track > tracks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_TrackList* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_CoverArt : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_CoverArt();
  virtual ~AudioCollectionResponse_CoverArt();

  AudioCollectionResponse_CoverArt(const AudioCollectionResponse_CoverArt& from);

  inline AudioCollectionResponse_CoverArt& operator=(const AudioCollectionResponse_CoverArt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_CoverArt& default_instance();

  void Swap(AudioCollectionResponse_CoverArt* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_CoverArt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_CoverArt& from);
  void MergeFrom(const AudioCollectionResponse_CoverArt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mime_type = 1;
  inline bool has_mime_type() const;
  inline void clear_mime_type();
  static const int kMimeTypeFieldNumber = 1;
  inline const ::std::string& mime_type() const;
  inline void set_mime_type(const ::std::string& value);
  inline void set_mime_type(const char* value);
  inline void set_mime_type(const char* value, size_t size);
  inline ::std::string* mutable_mime_type();
  inline ::std::string* release_mime_type();
  inline void set_allocated_mime_type(::std::string* mime_type);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.CoverArt)
 private:
  inline void set_has_mime_type();
  inline void clear_has_mime_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mime_type_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_CoverArt* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_Genre : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_Genre();
  virtual ~AudioCollectionResponse_Genre();

  AudioCollectionResponse_Genre(const AudioCollectionResponse_Genre& from);

  inline AudioCollectionResponse_Genre& operator=(const AudioCollectionResponse_Genre& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_Genre& default_instance();

  void Swap(AudioCollectionResponse_Genre* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_Genre* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_Genre& from);
  void MergeFrom(const AudioCollectionResponse_Genre& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.Genre)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_Genre* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_Artist : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_Artist();
  virtual ~AudioCollectionResponse_Artist();

  AudioCollectionResponse_Artist(const AudioCollectionResponse_Artist& from);

  inline AudioCollectionResponse_Artist& operator=(const AudioCollectionResponse_Artist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_Artist& default_instance();

  void Swap(AudioCollectionResponse_Artist* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_Artist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_Artist& from);
  void MergeFrom(const AudioCollectionResponse_Artist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.Artist)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_Artist* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_Release : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_Release();
  virtual ~AudioCollectionResponse_Release();

  AudioCollectionResponse_Release(const AudioCollectionResponse_Release& from);

  inline AudioCollectionResponse_Release& operator=(const AudioCollectionResponse_Release& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_Release& default_instance();

  void Swap(AudioCollectionResponse_Release* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_Release* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_Release& from);
  void MergeFrom(const AudioCollectionResponse_Release& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.Release)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_Release* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse_Track : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse_Track();
  virtual ~AudioCollectionResponse_Track();

  AudioCollectionResponse_Track(const AudioCollectionResponse_Track& from);

  inline AudioCollectionResponse_Track& operator=(const AudioCollectionResponse_Track& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse_Track& default_instance();

  void Swap(AudioCollectionResponse_Track* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse_Track* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse_Track& from);
  void MergeFrom(const AudioCollectionResponse_Track& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required uint64 artist_id = 2;
  inline bool has_artist_id() const;
  inline void clear_artist_id();
  static const int kArtistIdFieldNumber = 2;
  inline ::google::protobuf::uint64 artist_id() const;
  inline void set_artist_id(::google::protobuf::uint64 value);

  // required uint64 release_id = 3;
  inline bool has_release_id() const;
  inline void clear_release_id();
  static const int kReleaseIdFieldNumber = 3;
  inline ::google::protobuf::uint64 release_id() const;
  inline void set_release_id(::google::protobuf::uint64 value);

  // repeated uint64 genre_id = 4;
  inline int genre_id_size() const;
  inline void clear_genre_id();
  static const int kGenreIdFieldNumber = 4;
  inline ::google::protobuf::uint64 genre_id(int index) const;
  inline void set_genre_id(int index, ::google::protobuf::uint64 value);
  inline void add_genre_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      genre_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_genre_id();

  // optional uint32 disc_number = 5;
  inline bool has_disc_number() const;
  inline void clear_disc_number();
  static const int kDiscNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 disc_number() const;
  inline void set_disc_number(::google::protobuf::uint32 value);

  // optional uint32 track_number = 6;
  inline bool has_track_number() const;
  inline void clear_track_number();
  static const int kTrackNumberFieldNumber = 6;
  inline ::google::protobuf::uint32 track_number() const;
  inline void set_track_number(::google::protobuf::uint32 value);

  // required string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 duration_secs = 8;
  inline bool has_duration_secs() const;
  inline void clear_duration_secs();
  static const int kDurationSecsFieldNumber = 8;
  inline ::google::protobuf::uint32 duration_secs() const;
  inline void set_duration_secs(::google::protobuf::uint32 value);

  // optional string release_date = 9;
  inline bool has_release_date() const;
  inline void clear_release_date();
  static const int kReleaseDateFieldNumber = 9;
  inline const ::std::string& release_date() const;
  inline void set_release_date(const ::std::string& value);
  inline void set_release_date(const char* value);
  inline void set_release_date(const char* value, size_t size);
  inline ::std::string* mutable_release_date();
  inline ::std::string* release_release_date();
  inline void set_allocated_release_date(::std::string* release_date);

  // optional string original_release_date = 10;
  inline bool has_original_release_date() const;
  inline void clear_original_release_date();
  static const int kOriginalReleaseDateFieldNumber = 10;
  inline const ::std::string& original_release_date() const;
  inline void set_original_release_date(const ::std::string& value);
  inline void set_original_release_date(const char* value);
  inline void set_original_release_date(const char* value, size_t size);
  inline ::std::string* mutable_original_release_date();
  inline ::std::string* release_original_release_date();
  inline void set_allocated_original_release_date(::std::string* original_release_date);

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse.Track)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_artist_id();
  inline void clear_has_artist_id();
  inline void set_has_release_id();
  inline void clear_has_release_id();
  inline void set_has_disc_number();
  inline void clear_has_disc_number();
  inline void set_has_track_number();
  inline void clear_has_track_number();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration_secs();
  inline void clear_has_duration_secs();
  inline void set_has_release_date();
  inline void clear_has_release_date();
  inline void set_has_original_release_date();
  inline void clear_has_original_release_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 artist_id_;
  ::google::protobuf::uint64 release_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > genre_id_;
  ::google::protobuf::uint32 disc_number_;
  ::google::protobuf::uint32 track_number_;
  ::std::string* name_;
  ::std::string* release_date_;
  ::std::string* original_release_date_;
  ::google::protobuf::uint32 duration_secs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse_Track* default_instance_;
};
// -------------------------------------------------------------------

class AudioCollectionResponse : public ::google::protobuf::Message {
 public:
  AudioCollectionResponse();
  virtual ~AudioCollectionResponse();

  AudioCollectionResponse(const AudioCollectionResponse& from);

  inline AudioCollectionResponse& operator=(const AudioCollectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioCollectionResponse& default_instance();

  void Swap(AudioCollectionResponse* other);

  // implements Message ----------------------------------------------

  AudioCollectionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioCollectionResponse& from);
  void MergeFrom(const AudioCollectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AudioCollectionResponse_Revision Revision;
  typedef AudioCollectionResponse_GenreList GenreList;
  typedef AudioCollectionResponse_ArtistList ArtistList;
  typedef AudioCollectionResponse_ReleaseList ReleaseList;
  typedef AudioCollectionResponse_TrackList TrackList;
  typedef AudioCollectionResponse_CoverArt CoverArt;
  typedef AudioCollectionResponse_Genre Genre;
  typedef AudioCollectionResponse_Artist Artist;
  typedef AudioCollectionResponse_Release Release;
  typedef AudioCollectionResponse_Track Track;

  typedef AudioCollectionResponse_Type Type;
  static const Type TypeRevision = AudioCollectionResponse_Type_TypeRevision;
  static const Type TypeGenreList = AudioCollectionResponse_Type_TypeGenreList;
  static const Type TypeArtistList = AudioCollectionResponse_Type_TypeArtistList;
  static const Type TypeReleaseList = AudioCollectionResponse_Type_TypeReleaseList;
  static const Type TypeTrackList = AudioCollectionResponse_Type_TypeTrackList;
  static const Type TypeCoverArt = AudioCollectionResponse_Type_TypeCoverArt;
  static inline bool Type_IsValid(int value) {
    return AudioCollectionResponse_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AudioCollectionResponse_Type_Type_MIN;
  static const Type Type_MAX =
    AudioCollectionResponse_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AudioCollectionResponse_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AudioCollectionResponse_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AudioCollectionResponse_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AudioCollectionResponse_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Remote.AudioCollectionResponse.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Remote::AudioCollectionResponse_Type type() const;
  inline void set_type(::Remote::AudioCollectionResponse_Type value);

  // optional .Remote.AudioCollectionResponse.Revision revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline const ::Remote::AudioCollectionResponse_Revision& revision() const;
  inline ::Remote::AudioCollectionResponse_Revision* mutable_revision();
  inline ::Remote::AudioCollectionResponse_Revision* release_revision();
  inline void set_allocated_revision(::Remote::AudioCollectionResponse_Revision* revision);

  // optional .Remote.AudioCollectionResponse.GenreList genre_list = 3;
  inline bool has_genre_list() const;
  inline void clear_genre_list();
  static const int kGenreListFieldNumber = 3;
  inline const ::Remote::AudioCollectionResponse_GenreList& genre_list() const;
  inline ::Remote::AudioCollectionResponse_GenreList* mutable_genre_list();
  inline ::Remote::AudioCollectionResponse_GenreList* release_genre_list();
  inline void set_allocated_genre_list(::Remote::AudioCollectionResponse_GenreList* genre_list);

  // optional .Remote.AudioCollectionResponse.ArtistList artist_list = 4;
  inline bool has_artist_list() const;
  inline void clear_artist_list();
  static const int kArtistListFieldNumber = 4;
  inline const ::Remote::AudioCollectionResponse_ArtistList& artist_list() const;
  inline ::Remote::AudioCollectionResponse_ArtistList* mutable_artist_list();
  inline ::Remote::AudioCollectionResponse_ArtistList* release_artist_list();
  inline void set_allocated_artist_list(::Remote::AudioCollectionResponse_ArtistList* artist_list);

  // optional .Remote.AudioCollectionResponse.ReleaseList release_list = 5;
  inline bool has_release_list() const;
  inline void clear_release_list();
  static const int kReleaseListFieldNumber = 5;
  inline const ::Remote::AudioCollectionResponse_ReleaseList& release_list() const;
  inline ::Remote::AudioCollectionResponse_ReleaseList* mutable_release_list();
  inline ::Remote::AudioCollectionResponse_ReleaseList* release_release_list();
  inline void set_allocated_release_list(::Remote::AudioCollectionResponse_ReleaseList* release_list);

  // optional .Remote.AudioCollectionResponse.TrackList track_list = 6;
  inline bool has_track_list() const;
  inline void clear_track_list();
  static const int kTrackListFieldNumber = 6;
  inline const ::Remote::AudioCollectionResponse_TrackList& track_list() const;
  inline ::Remote::AudioCollectionResponse_TrackList* mutable_track_list();
  inline ::Remote::AudioCollectionResponse_TrackList* release_track_list();
  inline void set_allocated_track_list(::Remote::AudioCollectionResponse_TrackList* track_list);

  // repeated .Remote.AudioCollectionResponse.CoverArt cover_art = 7;
  inline int cover_art_size() const;
  inline void clear_cover_art();
  static const int kCoverArtFieldNumber = 7;
  inline const ::Remote::AudioCollectionResponse_CoverArt& cover_art(int index) const;
  inline ::Remote::AudioCollectionResponse_CoverArt* mutable_cover_art(int index);
  inline ::Remote::AudioCollectionResponse_CoverArt* add_cover_art();
  inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_CoverArt >&
      cover_art() const;
  inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_CoverArt >*
      mutable_cover_art();

  // @@protoc_insertion_point(class_scope:Remote.AudioCollectionResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_genre_list();
  inline void clear_has_genre_list();
  inline void set_has_artist_list();
  inline void clear_has_artist_list();
  inline void set_has_release_list();
  inline void clear_has_release_list();
  inline void set_has_track_list();
  inline void clear_has_track_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Remote::AudioCollectionResponse_Revision* revision_;
  ::Remote::AudioCollectionResponse_GenreList* genre_list_;
  ::Remote::AudioCollectionResponse_ArtistList* artist_list_;
  ::Remote::AudioCollectionResponse_ReleaseList* release_list_;
  ::Remote::AudioCollectionResponse_TrackList* track_list_;
  ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_CoverArt > cover_art_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_collection_2eproto();
  friend void protobuf_AssignDesc_collection_2eproto();
  friend void protobuf_ShutdownFile_collection_2eproto();

  void InitAsDefaultInstance();
  static AudioCollectionResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// AudioCollectionRequest_BatchParameter

// required uint32 offset = 1;
inline bool AudioCollectionRequest_BatchParameter::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionRequest_BatchParameter::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionRequest_BatchParameter::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionRequest_BatchParameter::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 AudioCollectionRequest_BatchParameter::offset() const {
  return offset_;
}
inline void AudioCollectionRequest_BatchParameter::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required uint32 size = 2;
inline bool AudioCollectionRequest_BatchParameter::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionRequest_BatchParameter::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionRequest_BatchParameter::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionRequest_BatchParameter::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 AudioCollectionRequest_BatchParameter::size() const {
  return size_;
}
inline void AudioCollectionRequest_BatchParameter::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// AudioCollectionRequest_GetGenreList

// required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
inline bool AudioCollectionRequest_GetGenreList::has_batch_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionRequest_GetGenreList::set_has_batch_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionRequest_GetGenreList::clear_has_batch_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionRequest_GetGenreList::clear_batch_parameter() {
  if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
  clear_has_batch_parameter();
}
inline const ::Remote::AudioCollectionRequest_BatchParameter& AudioCollectionRequest_GetGenreList::batch_parameter() const {
  return batch_parameter_ != NULL ? *batch_parameter_ : *default_instance_->batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetGenreList::mutable_batch_parameter() {
  set_has_batch_parameter();
  if (batch_parameter_ == NULL) batch_parameter_ = new ::Remote::AudioCollectionRequest_BatchParameter;
  return batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetGenreList::release_batch_parameter() {
  clear_has_batch_parameter();
  ::Remote::AudioCollectionRequest_BatchParameter* temp = batch_parameter_;
  batch_parameter_ = NULL;
  return temp;
}
inline void AudioCollectionRequest_GetGenreList::set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter) {
  delete batch_parameter_;
  batch_parameter_ = batch_parameter;
  if (batch_parameter) {
    set_has_batch_parameter();
  } else {
    clear_has_batch_parameter();
  }
}

// -------------------------------------------------------------------

// AudioCollectionRequest_GetArtistList

// required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
inline bool AudioCollectionRequest_GetArtistList::has_batch_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionRequest_GetArtistList::set_has_batch_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionRequest_GetArtistList::clear_has_batch_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionRequest_GetArtistList::clear_batch_parameter() {
  if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
  clear_has_batch_parameter();
}
inline const ::Remote::AudioCollectionRequest_BatchParameter& AudioCollectionRequest_GetArtistList::batch_parameter() const {
  return batch_parameter_ != NULL ? *batch_parameter_ : *default_instance_->batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetArtistList::mutable_batch_parameter() {
  set_has_batch_parameter();
  if (batch_parameter_ == NULL) batch_parameter_ = new ::Remote::AudioCollectionRequest_BatchParameter;
  return batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetArtistList::release_batch_parameter() {
  clear_has_batch_parameter();
  ::Remote::AudioCollectionRequest_BatchParameter* temp = batch_parameter_;
  batch_parameter_ = NULL;
  return temp;
}
inline void AudioCollectionRequest_GetArtistList::set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter) {
  delete batch_parameter_;
  batch_parameter_ = batch_parameter;
  if (batch_parameter) {
    set_has_batch_parameter();
  } else {
    clear_has_batch_parameter();
  }
}

// repeated uint64 genre_id = 2;
inline int AudioCollectionRequest_GetArtistList::genre_id_size() const {
  return genre_id_.size();
}
inline void AudioCollectionRequest_GetArtistList::clear_genre_id() {
  genre_id_.Clear();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetArtistList::genre_id(int index) const {
  return genre_id_.Get(index);
}
inline void AudioCollectionRequest_GetArtistList::set_genre_id(int index, ::google::protobuf::uint64 value) {
  genre_id_.Set(index, value);
}
inline void AudioCollectionRequest_GetArtistList::add_genre_id(::google::protobuf::uint64 value) {
  genre_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AudioCollectionRequest_GetArtistList::genre_id() const {
  return genre_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AudioCollectionRequest_GetArtistList::mutable_genre_id() {
  return &genre_id_;
}

// -------------------------------------------------------------------

// AudioCollectionRequest_GetReleaseList

// required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
inline bool AudioCollectionRequest_GetReleaseList::has_batch_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionRequest_GetReleaseList::set_has_batch_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionRequest_GetReleaseList::clear_has_batch_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionRequest_GetReleaseList::clear_batch_parameter() {
  if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
  clear_has_batch_parameter();
}
inline const ::Remote::AudioCollectionRequest_BatchParameter& AudioCollectionRequest_GetReleaseList::batch_parameter() const {
  return batch_parameter_ != NULL ? *batch_parameter_ : *default_instance_->batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetReleaseList::mutable_batch_parameter() {
  set_has_batch_parameter();
  if (batch_parameter_ == NULL) batch_parameter_ = new ::Remote::AudioCollectionRequest_BatchParameter;
  return batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetReleaseList::release_batch_parameter() {
  clear_has_batch_parameter();
  ::Remote::AudioCollectionRequest_BatchParameter* temp = batch_parameter_;
  batch_parameter_ = NULL;
  return temp;
}
inline void AudioCollectionRequest_GetReleaseList::set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter) {
  delete batch_parameter_;
  batch_parameter_ = batch_parameter;
  if (batch_parameter) {
    set_has_batch_parameter();
  } else {
    clear_has_batch_parameter();
  }
}

// repeated uint64 artist_id = 2;
inline int AudioCollectionRequest_GetReleaseList::artist_id_size() const {
  return artist_id_.size();
}
inline void AudioCollectionRequest_GetReleaseList::clear_artist_id() {
  artist_id_.Clear();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetReleaseList::artist_id(int index) const {
  return artist_id_.Get(index);
}
inline void AudioCollectionRequest_GetReleaseList::set_artist_id(int index, ::google::protobuf::uint64 value) {
  artist_id_.Set(index, value);
}
inline void AudioCollectionRequest_GetReleaseList::add_artist_id(::google::protobuf::uint64 value) {
  artist_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AudioCollectionRequest_GetReleaseList::artist_id() const {
  return artist_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AudioCollectionRequest_GetReleaseList::mutable_artist_id() {
  return &artist_id_;
}

// repeated uint64 filter_genre = 3;
inline int AudioCollectionRequest_GetReleaseList::filter_genre_size() const {
  return filter_genre_.size();
}
inline void AudioCollectionRequest_GetReleaseList::clear_filter_genre() {
  filter_genre_.Clear();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetReleaseList::filter_genre(int index) const {
  return filter_genre_.Get(index);
}
inline void AudioCollectionRequest_GetReleaseList::set_filter_genre(int index, ::google::protobuf::uint64 value) {
  filter_genre_.Set(index, value);
}
inline void AudioCollectionRequest_GetReleaseList::add_filter_genre(::google::protobuf::uint64 value) {
  filter_genre_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AudioCollectionRequest_GetReleaseList::filter_genre() const {
  return filter_genre_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AudioCollectionRequest_GetReleaseList::mutable_filter_genre() {
  return &filter_genre_;
}

// -------------------------------------------------------------------

// AudioCollectionRequest_GetTrackList

// required .Remote.AudioCollectionRequest.BatchParameter batch_parameter = 1;
inline bool AudioCollectionRequest_GetTrackList::has_batch_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionRequest_GetTrackList::set_has_batch_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionRequest_GetTrackList::clear_has_batch_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionRequest_GetTrackList::clear_batch_parameter() {
  if (batch_parameter_ != NULL) batch_parameter_->::Remote::AudioCollectionRequest_BatchParameter::Clear();
  clear_has_batch_parameter();
}
inline const ::Remote::AudioCollectionRequest_BatchParameter& AudioCollectionRequest_GetTrackList::batch_parameter() const {
  return batch_parameter_ != NULL ? *batch_parameter_ : *default_instance_->batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetTrackList::mutable_batch_parameter() {
  set_has_batch_parameter();
  if (batch_parameter_ == NULL) batch_parameter_ = new ::Remote::AudioCollectionRequest_BatchParameter;
  return batch_parameter_;
}
inline ::Remote::AudioCollectionRequest_BatchParameter* AudioCollectionRequest_GetTrackList::release_batch_parameter() {
  clear_has_batch_parameter();
  ::Remote::AudioCollectionRequest_BatchParameter* temp = batch_parameter_;
  batch_parameter_ = NULL;
  return temp;
}
inline void AudioCollectionRequest_GetTrackList::set_allocated_batch_parameter(::Remote::AudioCollectionRequest_BatchParameter* batch_parameter) {
  delete batch_parameter_;
  batch_parameter_ = batch_parameter;
  if (batch_parameter) {
    set_has_batch_parameter();
  } else {
    clear_has_batch_parameter();
  }
}

// repeated uint64 artist_id = 2;
inline int AudioCollectionRequest_GetTrackList::artist_id_size() const {
  return artist_id_.size();
}
inline void AudioCollectionRequest_GetTrackList::clear_artist_id() {
  artist_id_.Clear();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetTrackList::artist_id(int index) const {
  return artist_id_.Get(index);
}
inline void AudioCollectionRequest_GetTrackList::set_artist_id(int index, ::google::protobuf::uint64 value) {
  artist_id_.Set(index, value);
}
inline void AudioCollectionRequest_GetTrackList::add_artist_id(::google::protobuf::uint64 value) {
  artist_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AudioCollectionRequest_GetTrackList::artist_id() const {
  return artist_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AudioCollectionRequest_GetTrackList::mutable_artist_id() {
  return &artist_id_;
}

// repeated uint64 release_id = 3;
inline int AudioCollectionRequest_GetTrackList::release_id_size() const {
  return release_id_.size();
}
inline void AudioCollectionRequest_GetTrackList::clear_release_id() {
  release_id_.Clear();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetTrackList::release_id(int index) const {
  return release_id_.Get(index);
}
inline void AudioCollectionRequest_GetTrackList::set_release_id(int index, ::google::protobuf::uint64 value) {
  release_id_.Set(index, value);
}
inline void AudioCollectionRequest_GetTrackList::add_release_id(::google::protobuf::uint64 value) {
  release_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AudioCollectionRequest_GetTrackList::release_id() const {
  return release_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AudioCollectionRequest_GetTrackList::mutable_release_id() {
  return &release_id_;
}

// repeated uint64 genre_id = 4;
inline int AudioCollectionRequest_GetTrackList::genre_id_size() const {
  return genre_id_.size();
}
inline void AudioCollectionRequest_GetTrackList::clear_genre_id() {
  genre_id_.Clear();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetTrackList::genre_id(int index) const {
  return genre_id_.Get(index);
}
inline void AudioCollectionRequest_GetTrackList::set_genre_id(int index, ::google::protobuf::uint64 value) {
  genre_id_.Set(index, value);
}
inline void AudioCollectionRequest_GetTrackList::add_genre_id(::google::protobuf::uint64 value) {
  genre_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AudioCollectionRequest_GetTrackList::genre_id() const {
  return genre_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AudioCollectionRequest_GetTrackList::mutable_genre_id() {
  return &genre_id_;
}

// -------------------------------------------------------------------

// AudioCollectionRequest_GetCoverArt

// required .Remote.AudioCollectionRequest.GetCoverArt.Type type = 1;
inline bool AudioCollectionRequest_GetCoverArt::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionRequest_GetCoverArt::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Remote::AudioCollectionRequest_GetCoverArt_Type AudioCollectionRequest_GetCoverArt::type() const {
  return static_cast< ::Remote::AudioCollectionRequest_GetCoverArt_Type >(type_);
}
inline void AudioCollectionRequest_GetCoverArt::set_type(::Remote::AudioCollectionRequest_GetCoverArt_Type value) {
  assert(::Remote::AudioCollectionRequest_GetCoverArt_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 release_id = 2;
inline bool AudioCollectionRequest_GetCoverArt::has_release_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionRequest_GetCoverArt::set_has_release_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_has_release_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_release_id() {
  release_id_ = GOOGLE_ULONGLONG(0);
  clear_has_release_id();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetCoverArt::release_id() const {
  return release_id_;
}
inline void AudioCollectionRequest_GetCoverArt::set_release_id(::google::protobuf::uint64 value) {
  set_has_release_id();
  release_id_ = value;
}

// optional uint64 track_id = 3;
inline bool AudioCollectionRequest_GetCoverArt::has_track_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioCollectionRequest_GetCoverArt::set_has_track_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_has_track_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_track_id() {
  track_id_ = GOOGLE_ULONGLONG(0);
  clear_has_track_id();
}
inline ::google::protobuf::uint64 AudioCollectionRequest_GetCoverArt::track_id() const {
  return track_id_;
}
inline void AudioCollectionRequest_GetCoverArt::set_track_id(::google::protobuf::uint64 value) {
  set_has_track_id();
  track_id_ = value;
}

// required uint32 size = 4;
inline bool AudioCollectionRequest_GetCoverArt::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioCollectionRequest_GetCoverArt::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioCollectionRequest_GetCoverArt::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 AudioCollectionRequest_GetCoverArt::size() const {
  return size_;
}
inline void AudioCollectionRequest_GetCoverArt::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// AudioCollectionRequest

// required .Remote.AudioCollectionRequest.Type type = 1;
inline bool AudioCollectionRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Remote::AudioCollectionRequest_Type AudioCollectionRequest::type() const {
  return static_cast< ::Remote::AudioCollectionRequest_Type >(type_);
}
inline void AudioCollectionRequest::set_type(::Remote::AudioCollectionRequest_Type value) {
  assert(::Remote::AudioCollectionRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Remote.AudioCollectionRequest.GetGenreList get_genres = 2;
inline bool AudioCollectionRequest::has_get_genres() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionRequest::set_has_get_genres() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionRequest::clear_has_get_genres() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionRequest::clear_get_genres() {
  if (get_genres_ != NULL) get_genres_->::Remote::AudioCollectionRequest_GetGenreList::Clear();
  clear_has_get_genres();
}
inline const ::Remote::AudioCollectionRequest_GetGenreList& AudioCollectionRequest::get_genres() const {
  return get_genres_ != NULL ? *get_genres_ : *default_instance_->get_genres_;
}
inline ::Remote::AudioCollectionRequest_GetGenreList* AudioCollectionRequest::mutable_get_genres() {
  set_has_get_genres();
  if (get_genres_ == NULL) get_genres_ = new ::Remote::AudioCollectionRequest_GetGenreList;
  return get_genres_;
}
inline ::Remote::AudioCollectionRequest_GetGenreList* AudioCollectionRequest::release_get_genres() {
  clear_has_get_genres();
  ::Remote::AudioCollectionRequest_GetGenreList* temp = get_genres_;
  get_genres_ = NULL;
  return temp;
}
inline void AudioCollectionRequest::set_allocated_get_genres(::Remote::AudioCollectionRequest_GetGenreList* get_genres) {
  delete get_genres_;
  get_genres_ = get_genres;
  if (get_genres) {
    set_has_get_genres();
  } else {
    clear_has_get_genres();
  }
}

// optional .Remote.AudioCollectionRequest.GetArtistList get_artists = 3;
inline bool AudioCollectionRequest::has_get_artists() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioCollectionRequest::set_has_get_artists() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioCollectionRequest::clear_has_get_artists() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioCollectionRequest::clear_get_artists() {
  if (get_artists_ != NULL) get_artists_->::Remote::AudioCollectionRequest_GetArtistList::Clear();
  clear_has_get_artists();
}
inline const ::Remote::AudioCollectionRequest_GetArtistList& AudioCollectionRequest::get_artists() const {
  return get_artists_ != NULL ? *get_artists_ : *default_instance_->get_artists_;
}
inline ::Remote::AudioCollectionRequest_GetArtistList* AudioCollectionRequest::mutable_get_artists() {
  set_has_get_artists();
  if (get_artists_ == NULL) get_artists_ = new ::Remote::AudioCollectionRequest_GetArtistList;
  return get_artists_;
}
inline ::Remote::AudioCollectionRequest_GetArtistList* AudioCollectionRequest::release_get_artists() {
  clear_has_get_artists();
  ::Remote::AudioCollectionRequest_GetArtistList* temp = get_artists_;
  get_artists_ = NULL;
  return temp;
}
inline void AudioCollectionRequest::set_allocated_get_artists(::Remote::AudioCollectionRequest_GetArtistList* get_artists) {
  delete get_artists_;
  get_artists_ = get_artists;
  if (get_artists) {
    set_has_get_artists();
  } else {
    clear_has_get_artists();
  }
}

// optional .Remote.AudioCollectionRequest.GetReleaseList get_releases = 4;
inline bool AudioCollectionRequest::has_get_releases() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioCollectionRequest::set_has_get_releases() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioCollectionRequest::clear_has_get_releases() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioCollectionRequest::clear_get_releases() {
  if (get_releases_ != NULL) get_releases_->::Remote::AudioCollectionRequest_GetReleaseList::Clear();
  clear_has_get_releases();
}
inline const ::Remote::AudioCollectionRequest_GetReleaseList& AudioCollectionRequest::get_releases() const {
  return get_releases_ != NULL ? *get_releases_ : *default_instance_->get_releases_;
}
inline ::Remote::AudioCollectionRequest_GetReleaseList* AudioCollectionRequest::mutable_get_releases() {
  set_has_get_releases();
  if (get_releases_ == NULL) get_releases_ = new ::Remote::AudioCollectionRequest_GetReleaseList;
  return get_releases_;
}
inline ::Remote::AudioCollectionRequest_GetReleaseList* AudioCollectionRequest::release_get_releases() {
  clear_has_get_releases();
  ::Remote::AudioCollectionRequest_GetReleaseList* temp = get_releases_;
  get_releases_ = NULL;
  return temp;
}
inline void AudioCollectionRequest::set_allocated_get_releases(::Remote::AudioCollectionRequest_GetReleaseList* get_releases) {
  delete get_releases_;
  get_releases_ = get_releases;
  if (get_releases) {
    set_has_get_releases();
  } else {
    clear_has_get_releases();
  }
}

// optional .Remote.AudioCollectionRequest.GetTrackList get_tracks = 5;
inline bool AudioCollectionRequest::has_get_tracks() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioCollectionRequest::set_has_get_tracks() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioCollectionRequest::clear_has_get_tracks() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioCollectionRequest::clear_get_tracks() {
  if (get_tracks_ != NULL) get_tracks_->::Remote::AudioCollectionRequest_GetTrackList::Clear();
  clear_has_get_tracks();
}
inline const ::Remote::AudioCollectionRequest_GetTrackList& AudioCollectionRequest::get_tracks() const {
  return get_tracks_ != NULL ? *get_tracks_ : *default_instance_->get_tracks_;
}
inline ::Remote::AudioCollectionRequest_GetTrackList* AudioCollectionRequest::mutable_get_tracks() {
  set_has_get_tracks();
  if (get_tracks_ == NULL) get_tracks_ = new ::Remote::AudioCollectionRequest_GetTrackList;
  return get_tracks_;
}
inline ::Remote::AudioCollectionRequest_GetTrackList* AudioCollectionRequest::release_get_tracks() {
  clear_has_get_tracks();
  ::Remote::AudioCollectionRequest_GetTrackList* temp = get_tracks_;
  get_tracks_ = NULL;
  return temp;
}
inline void AudioCollectionRequest::set_allocated_get_tracks(::Remote::AudioCollectionRequest_GetTrackList* get_tracks) {
  delete get_tracks_;
  get_tracks_ = get_tracks;
  if (get_tracks) {
    set_has_get_tracks();
  } else {
    clear_has_get_tracks();
  }
}

// optional .Remote.AudioCollectionRequest.GetCoverArt get_cover_art = 6;
inline bool AudioCollectionRequest::has_get_cover_art() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioCollectionRequest::set_has_get_cover_art() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioCollectionRequest::clear_has_get_cover_art() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioCollectionRequest::clear_get_cover_art() {
  if (get_cover_art_ != NULL) get_cover_art_->::Remote::AudioCollectionRequest_GetCoverArt::Clear();
  clear_has_get_cover_art();
}
inline const ::Remote::AudioCollectionRequest_GetCoverArt& AudioCollectionRequest::get_cover_art() const {
  return get_cover_art_ != NULL ? *get_cover_art_ : *default_instance_->get_cover_art_;
}
inline ::Remote::AudioCollectionRequest_GetCoverArt* AudioCollectionRequest::mutable_get_cover_art() {
  set_has_get_cover_art();
  if (get_cover_art_ == NULL) get_cover_art_ = new ::Remote::AudioCollectionRequest_GetCoverArt;
  return get_cover_art_;
}
inline ::Remote::AudioCollectionRequest_GetCoverArt* AudioCollectionRequest::release_get_cover_art() {
  clear_has_get_cover_art();
  ::Remote::AudioCollectionRequest_GetCoverArt* temp = get_cover_art_;
  get_cover_art_ = NULL;
  return temp;
}
inline void AudioCollectionRequest::set_allocated_get_cover_art(::Remote::AudioCollectionRequest_GetCoverArt* get_cover_art) {
  delete get_cover_art_;
  get_cover_art_ = get_cover_art;
  if (get_cover_art) {
    set_has_get_cover_art();
  } else {
    clear_has_get_cover_art();
  }
}

// -------------------------------------------------------------------

// AudioCollectionResponse_Revision

// required uint64 rev = 1;
inline bool AudioCollectionResponse_Revision::has_rev() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionResponse_Revision::set_has_rev() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionResponse_Revision::clear_has_rev() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionResponse_Revision::clear_rev() {
  rev_ = GOOGLE_ULONGLONG(0);
  clear_has_rev();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Revision::rev() const {
  return rev_;
}
inline void AudioCollectionResponse_Revision::set_rev(::google::protobuf::uint64 value) {
  set_has_rev();
  rev_ = value;
}

// -------------------------------------------------------------------

// AudioCollectionResponse_GenreList

// repeated .Remote.AudioCollectionResponse.Genre genres = 2;
inline int AudioCollectionResponse_GenreList::genres_size() const {
  return genres_.size();
}
inline void AudioCollectionResponse_GenreList::clear_genres() {
  genres_.Clear();
}
inline const ::Remote::AudioCollectionResponse_Genre& AudioCollectionResponse_GenreList::genres(int index) const {
  return genres_.Get(index);
}
inline ::Remote::AudioCollectionResponse_Genre* AudioCollectionResponse_GenreList::mutable_genres(int index) {
  return genres_.Mutable(index);
}
inline ::Remote::AudioCollectionResponse_Genre* AudioCollectionResponse_GenreList::add_genres() {
  return genres_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Genre >&
AudioCollectionResponse_GenreList::genres() const {
  return genres_;
}
inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Genre >*
AudioCollectionResponse_GenreList::mutable_genres() {
  return &genres_;
}

// -------------------------------------------------------------------

// AudioCollectionResponse_ArtistList

// repeated .Remote.AudioCollectionResponse.Artist artists = 2;
inline int AudioCollectionResponse_ArtistList::artists_size() const {
  return artists_.size();
}
inline void AudioCollectionResponse_ArtistList::clear_artists() {
  artists_.Clear();
}
inline const ::Remote::AudioCollectionResponse_Artist& AudioCollectionResponse_ArtistList::artists(int index) const {
  return artists_.Get(index);
}
inline ::Remote::AudioCollectionResponse_Artist* AudioCollectionResponse_ArtistList::mutable_artists(int index) {
  return artists_.Mutable(index);
}
inline ::Remote::AudioCollectionResponse_Artist* AudioCollectionResponse_ArtistList::add_artists() {
  return artists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Artist >&
AudioCollectionResponse_ArtistList::artists() const {
  return artists_;
}
inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Artist >*
AudioCollectionResponse_ArtistList::mutable_artists() {
  return &artists_;
}

// -------------------------------------------------------------------

// AudioCollectionResponse_ReleaseList

// repeated .Remote.AudioCollectionResponse.Release releases = 2;
inline int AudioCollectionResponse_ReleaseList::releases_size() const {
  return releases_.size();
}
inline void AudioCollectionResponse_ReleaseList::clear_releases() {
  releases_.Clear();
}
inline const ::Remote::AudioCollectionResponse_Release& AudioCollectionResponse_ReleaseList::releases(int index) const {
  return releases_.Get(index);
}
inline ::Remote::AudioCollectionResponse_Release* AudioCollectionResponse_ReleaseList::mutable_releases(int index) {
  return releases_.Mutable(index);
}
inline ::Remote::AudioCollectionResponse_Release* AudioCollectionResponse_ReleaseList::add_releases() {
  return releases_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Release >&
AudioCollectionResponse_ReleaseList::releases() const {
  return releases_;
}
inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Release >*
AudioCollectionResponse_ReleaseList::mutable_releases() {
  return &releases_;
}

// -------------------------------------------------------------------

// AudioCollectionResponse_TrackList

// repeated .Remote.AudioCollectionResponse.Track tracks = 2;
inline int AudioCollectionResponse_TrackList::tracks_size() const {
  return tracks_.size();
}
inline void AudioCollectionResponse_TrackList::clear_tracks() {
  tracks_.Clear();
}
inline const ::Remote::AudioCollectionResponse_Track& AudioCollectionResponse_TrackList::tracks(int index) const {
  return tracks_.Get(index);
}
inline ::Remote::AudioCollectionResponse_Track* AudioCollectionResponse_TrackList::mutable_tracks(int index) {
  return tracks_.Mutable(index);
}
inline ::Remote::AudioCollectionResponse_Track* AudioCollectionResponse_TrackList::add_tracks() {
  return tracks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Track >&
AudioCollectionResponse_TrackList::tracks() const {
  return tracks_;
}
inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_Track >*
AudioCollectionResponse_TrackList::mutable_tracks() {
  return &tracks_;
}

// -------------------------------------------------------------------

// AudioCollectionResponse_CoverArt

// optional string mime_type = 1;
inline bool AudioCollectionResponse_CoverArt::has_mime_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionResponse_CoverArt::set_has_mime_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionResponse_CoverArt::clear_has_mime_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionResponse_CoverArt::clear_mime_type() {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    mime_type_->clear();
  }
  clear_has_mime_type();
}
inline const ::std::string& AudioCollectionResponse_CoverArt::mime_type() const {
  return *mime_type_;
}
inline void AudioCollectionResponse_CoverArt::set_mime_type(const ::std::string& value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void AudioCollectionResponse_CoverArt::set_mime_type(const char* value) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(value);
}
inline void AudioCollectionResponse_CoverArt::set_mime_type(const char* value, size_t size) {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  mime_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_CoverArt::mutable_mime_type() {
  set_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    mime_type_ = new ::std::string;
  }
  return mime_type_;
}
inline ::std::string* AudioCollectionResponse_CoverArt::release_mime_type() {
  clear_has_mime_type();
  if (mime_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mime_type_;
    mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_CoverArt::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type_ != &::google::protobuf::internal::kEmptyString) {
    delete mime_type_;
  }
  if (mime_type) {
    set_has_mime_type();
    mime_type_ = mime_type;
  } else {
    clear_has_mime_type();
    mime_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes data = 2;
inline bool AudioCollectionResponse_CoverArt::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionResponse_CoverArt::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionResponse_CoverArt::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionResponse_CoverArt::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& AudioCollectionResponse_CoverArt::data() const {
  return *data_;
}
inline void AudioCollectionResponse_CoverArt::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AudioCollectionResponse_CoverArt::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AudioCollectionResponse_CoverArt::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_CoverArt::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* AudioCollectionResponse_CoverArt::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_CoverArt::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioCollectionResponse_Genre

// required uint64 id = 1;
inline bool AudioCollectionResponse_Genre::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionResponse_Genre::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionResponse_Genre::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionResponse_Genre::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Genre::id() const {
  return id_;
}
inline void AudioCollectionResponse_Genre::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool AudioCollectionResponse_Genre::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionResponse_Genre::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionResponse_Genre::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionResponse_Genre::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AudioCollectionResponse_Genre::name() const {
  return *name_;
}
inline void AudioCollectionResponse_Genre::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Genre::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Genre::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_Genre::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AudioCollectionResponse_Genre::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_Genre::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioCollectionResponse_Artist

// required uint64 id = 1;
inline bool AudioCollectionResponse_Artist::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionResponse_Artist::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionResponse_Artist::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionResponse_Artist::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Artist::id() const {
  return id_;
}
inline void AudioCollectionResponse_Artist::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool AudioCollectionResponse_Artist::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionResponse_Artist::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionResponse_Artist::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionResponse_Artist::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AudioCollectionResponse_Artist::name() const {
  return *name_;
}
inline void AudioCollectionResponse_Artist::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Artist::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Artist::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_Artist::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AudioCollectionResponse_Artist::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_Artist::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioCollectionResponse_Release

// required uint64 id = 1;
inline bool AudioCollectionResponse_Release::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionResponse_Release::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionResponse_Release::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionResponse_Release::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Release::id() const {
  return id_;
}
inline void AudioCollectionResponse_Release::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool AudioCollectionResponse_Release::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionResponse_Release::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionResponse_Release::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionResponse_Release::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AudioCollectionResponse_Release::name() const {
  return *name_;
}
inline void AudioCollectionResponse_Release::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Release::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Release::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_Release::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AudioCollectionResponse_Release::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_Release::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioCollectionResponse_Track

// required uint64 id = 1;
inline bool AudioCollectionResponse_Track::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionResponse_Track::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionResponse_Track::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Track::id() const {
  return id_;
}
inline void AudioCollectionResponse_Track::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required uint64 artist_id = 2;
inline bool AudioCollectionResponse_Track::has_artist_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_artist_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionResponse_Track::clear_has_artist_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionResponse_Track::clear_artist_id() {
  artist_id_ = GOOGLE_ULONGLONG(0);
  clear_has_artist_id();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Track::artist_id() const {
  return artist_id_;
}
inline void AudioCollectionResponse_Track::set_artist_id(::google::protobuf::uint64 value) {
  set_has_artist_id();
  artist_id_ = value;
}

// required uint64 release_id = 3;
inline bool AudioCollectionResponse_Track::has_release_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_release_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioCollectionResponse_Track::clear_has_release_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioCollectionResponse_Track::clear_release_id() {
  release_id_ = GOOGLE_ULONGLONG(0);
  clear_has_release_id();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Track::release_id() const {
  return release_id_;
}
inline void AudioCollectionResponse_Track::set_release_id(::google::protobuf::uint64 value) {
  set_has_release_id();
  release_id_ = value;
}

// repeated uint64 genre_id = 4;
inline int AudioCollectionResponse_Track::genre_id_size() const {
  return genre_id_.size();
}
inline void AudioCollectionResponse_Track::clear_genre_id() {
  genre_id_.Clear();
}
inline ::google::protobuf::uint64 AudioCollectionResponse_Track::genre_id(int index) const {
  return genre_id_.Get(index);
}
inline void AudioCollectionResponse_Track::set_genre_id(int index, ::google::protobuf::uint64 value) {
  genre_id_.Set(index, value);
}
inline void AudioCollectionResponse_Track::add_genre_id(::google::protobuf::uint64 value) {
  genre_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AudioCollectionResponse_Track::genre_id() const {
  return genre_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AudioCollectionResponse_Track::mutable_genre_id() {
  return &genre_id_;
}

// optional uint32 disc_number = 5;
inline bool AudioCollectionResponse_Track::has_disc_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_disc_number() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioCollectionResponse_Track::clear_has_disc_number() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioCollectionResponse_Track::clear_disc_number() {
  disc_number_ = 0u;
  clear_has_disc_number();
}
inline ::google::protobuf::uint32 AudioCollectionResponse_Track::disc_number() const {
  return disc_number_;
}
inline void AudioCollectionResponse_Track::set_disc_number(::google::protobuf::uint32 value) {
  set_has_disc_number();
  disc_number_ = value;
}

// optional uint32 track_number = 6;
inline bool AudioCollectionResponse_Track::has_track_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_track_number() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioCollectionResponse_Track::clear_has_track_number() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioCollectionResponse_Track::clear_track_number() {
  track_number_ = 0u;
  clear_has_track_number();
}
inline ::google::protobuf::uint32 AudioCollectionResponse_Track::track_number() const {
  return track_number_;
}
inline void AudioCollectionResponse_Track::set_track_number(::google::protobuf::uint32 value) {
  set_has_track_number();
  track_number_ = value;
}

// required string name = 7;
inline bool AudioCollectionResponse_Track::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AudioCollectionResponse_Track::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AudioCollectionResponse_Track::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AudioCollectionResponse_Track::name() const {
  return *name_;
}
inline void AudioCollectionResponse_Track::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Track::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AudioCollectionResponse_Track::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_Track::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AudioCollectionResponse_Track::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_Track::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 duration_secs = 8;
inline bool AudioCollectionResponse_Track::has_duration_secs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_duration_secs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AudioCollectionResponse_Track::clear_has_duration_secs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AudioCollectionResponse_Track::clear_duration_secs() {
  duration_secs_ = 0u;
  clear_has_duration_secs();
}
inline ::google::protobuf::uint32 AudioCollectionResponse_Track::duration_secs() const {
  return duration_secs_;
}
inline void AudioCollectionResponse_Track::set_duration_secs(::google::protobuf::uint32 value) {
  set_has_duration_secs();
  duration_secs_ = value;
}

// optional string release_date = 9;
inline bool AudioCollectionResponse_Track::has_release_date() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_release_date() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AudioCollectionResponse_Track::clear_has_release_date() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AudioCollectionResponse_Track::clear_release_date() {
  if (release_date_ != &::google::protobuf::internal::kEmptyString) {
    release_date_->clear();
  }
  clear_has_release_date();
}
inline const ::std::string& AudioCollectionResponse_Track::release_date() const {
  return *release_date_;
}
inline void AudioCollectionResponse_Track::set_release_date(const ::std::string& value) {
  set_has_release_date();
  if (release_date_ == &::google::protobuf::internal::kEmptyString) {
    release_date_ = new ::std::string;
  }
  release_date_->assign(value);
}
inline void AudioCollectionResponse_Track::set_release_date(const char* value) {
  set_has_release_date();
  if (release_date_ == &::google::protobuf::internal::kEmptyString) {
    release_date_ = new ::std::string;
  }
  release_date_->assign(value);
}
inline void AudioCollectionResponse_Track::set_release_date(const char* value, size_t size) {
  set_has_release_date();
  if (release_date_ == &::google::protobuf::internal::kEmptyString) {
    release_date_ = new ::std::string;
  }
  release_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_Track::mutable_release_date() {
  set_has_release_date();
  if (release_date_ == &::google::protobuf::internal::kEmptyString) {
    release_date_ = new ::std::string;
  }
  return release_date_;
}
inline ::std::string* AudioCollectionResponse_Track::release_release_date() {
  clear_has_release_date();
  if (release_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = release_date_;
    release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_Track::set_allocated_release_date(::std::string* release_date) {
  if (release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete release_date_;
  }
  if (release_date) {
    set_has_release_date();
    release_date_ = release_date;
  } else {
    clear_has_release_date();
    release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string original_release_date = 10;
inline bool AudioCollectionResponse_Track::has_original_release_date() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AudioCollectionResponse_Track::set_has_original_release_date() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AudioCollectionResponse_Track::clear_has_original_release_date() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AudioCollectionResponse_Track::clear_original_release_date() {
  if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
    original_release_date_->clear();
  }
  clear_has_original_release_date();
}
inline const ::std::string& AudioCollectionResponse_Track::original_release_date() const {
  return *original_release_date_;
}
inline void AudioCollectionResponse_Track::set_original_release_date(const ::std::string& value) {
  set_has_original_release_date();
  if (original_release_date_ == &::google::protobuf::internal::kEmptyString) {
    original_release_date_ = new ::std::string;
  }
  original_release_date_->assign(value);
}
inline void AudioCollectionResponse_Track::set_original_release_date(const char* value) {
  set_has_original_release_date();
  if (original_release_date_ == &::google::protobuf::internal::kEmptyString) {
    original_release_date_ = new ::std::string;
  }
  original_release_date_->assign(value);
}
inline void AudioCollectionResponse_Track::set_original_release_date(const char* value, size_t size) {
  set_has_original_release_date();
  if (original_release_date_ == &::google::protobuf::internal::kEmptyString) {
    original_release_date_ = new ::std::string;
  }
  original_release_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AudioCollectionResponse_Track::mutable_original_release_date() {
  set_has_original_release_date();
  if (original_release_date_ == &::google::protobuf::internal::kEmptyString) {
    original_release_date_ = new ::std::string;
  }
  return original_release_date_;
}
inline ::std::string* AudioCollectionResponse_Track::release_original_release_date() {
  clear_has_original_release_date();
  if (original_release_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = original_release_date_;
    original_release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AudioCollectionResponse_Track::set_allocated_original_release_date(::std::string* original_release_date) {
  if (original_release_date_ != &::google::protobuf::internal::kEmptyString) {
    delete original_release_date_;
  }
  if (original_release_date) {
    set_has_original_release_date();
    original_release_date_ = original_release_date;
  } else {
    clear_has_original_release_date();
    original_release_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AudioCollectionResponse

// required .Remote.AudioCollectionResponse.Type type = 1;
inline bool AudioCollectionResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioCollectionResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioCollectionResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioCollectionResponse::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Remote::AudioCollectionResponse_Type AudioCollectionResponse::type() const {
  return static_cast< ::Remote::AudioCollectionResponse_Type >(type_);
}
inline void AudioCollectionResponse::set_type(::Remote::AudioCollectionResponse_Type value) {
  assert(::Remote::AudioCollectionResponse_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Remote.AudioCollectionResponse.Revision revision = 2;
inline bool AudioCollectionResponse::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioCollectionResponse::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioCollectionResponse::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioCollectionResponse::clear_revision() {
  if (revision_ != NULL) revision_->::Remote::AudioCollectionResponse_Revision::Clear();
  clear_has_revision();
}
inline const ::Remote::AudioCollectionResponse_Revision& AudioCollectionResponse::revision() const {
  return revision_ != NULL ? *revision_ : *default_instance_->revision_;
}
inline ::Remote::AudioCollectionResponse_Revision* AudioCollectionResponse::mutable_revision() {
  set_has_revision();
  if (revision_ == NULL) revision_ = new ::Remote::AudioCollectionResponse_Revision;
  return revision_;
}
inline ::Remote::AudioCollectionResponse_Revision* AudioCollectionResponse::release_revision() {
  clear_has_revision();
  ::Remote::AudioCollectionResponse_Revision* temp = revision_;
  revision_ = NULL;
  return temp;
}
inline void AudioCollectionResponse::set_allocated_revision(::Remote::AudioCollectionResponse_Revision* revision) {
  delete revision_;
  revision_ = revision;
  if (revision) {
    set_has_revision();
  } else {
    clear_has_revision();
  }
}

// optional .Remote.AudioCollectionResponse.GenreList genre_list = 3;
inline bool AudioCollectionResponse::has_genre_list() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioCollectionResponse::set_has_genre_list() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioCollectionResponse::clear_has_genre_list() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioCollectionResponse::clear_genre_list() {
  if (genre_list_ != NULL) genre_list_->::Remote::AudioCollectionResponse_GenreList::Clear();
  clear_has_genre_list();
}
inline const ::Remote::AudioCollectionResponse_GenreList& AudioCollectionResponse::genre_list() const {
  return genre_list_ != NULL ? *genre_list_ : *default_instance_->genre_list_;
}
inline ::Remote::AudioCollectionResponse_GenreList* AudioCollectionResponse::mutable_genre_list() {
  set_has_genre_list();
  if (genre_list_ == NULL) genre_list_ = new ::Remote::AudioCollectionResponse_GenreList;
  return genre_list_;
}
inline ::Remote::AudioCollectionResponse_GenreList* AudioCollectionResponse::release_genre_list() {
  clear_has_genre_list();
  ::Remote::AudioCollectionResponse_GenreList* temp = genre_list_;
  genre_list_ = NULL;
  return temp;
}
inline void AudioCollectionResponse::set_allocated_genre_list(::Remote::AudioCollectionResponse_GenreList* genre_list) {
  delete genre_list_;
  genre_list_ = genre_list;
  if (genre_list) {
    set_has_genre_list();
  } else {
    clear_has_genre_list();
  }
}

// optional .Remote.AudioCollectionResponse.ArtistList artist_list = 4;
inline bool AudioCollectionResponse::has_artist_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioCollectionResponse::set_has_artist_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioCollectionResponse::clear_has_artist_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioCollectionResponse::clear_artist_list() {
  if (artist_list_ != NULL) artist_list_->::Remote::AudioCollectionResponse_ArtistList::Clear();
  clear_has_artist_list();
}
inline const ::Remote::AudioCollectionResponse_ArtistList& AudioCollectionResponse::artist_list() const {
  return artist_list_ != NULL ? *artist_list_ : *default_instance_->artist_list_;
}
inline ::Remote::AudioCollectionResponse_ArtistList* AudioCollectionResponse::mutable_artist_list() {
  set_has_artist_list();
  if (artist_list_ == NULL) artist_list_ = new ::Remote::AudioCollectionResponse_ArtistList;
  return artist_list_;
}
inline ::Remote::AudioCollectionResponse_ArtistList* AudioCollectionResponse::release_artist_list() {
  clear_has_artist_list();
  ::Remote::AudioCollectionResponse_ArtistList* temp = artist_list_;
  artist_list_ = NULL;
  return temp;
}
inline void AudioCollectionResponse::set_allocated_artist_list(::Remote::AudioCollectionResponse_ArtistList* artist_list) {
  delete artist_list_;
  artist_list_ = artist_list;
  if (artist_list) {
    set_has_artist_list();
  } else {
    clear_has_artist_list();
  }
}

// optional .Remote.AudioCollectionResponse.ReleaseList release_list = 5;
inline bool AudioCollectionResponse::has_release_list() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioCollectionResponse::set_has_release_list() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioCollectionResponse::clear_has_release_list() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioCollectionResponse::clear_release_list() {
  if (release_list_ != NULL) release_list_->::Remote::AudioCollectionResponse_ReleaseList::Clear();
  clear_has_release_list();
}
inline const ::Remote::AudioCollectionResponse_ReleaseList& AudioCollectionResponse::release_list() const {
  return release_list_ != NULL ? *release_list_ : *default_instance_->release_list_;
}
inline ::Remote::AudioCollectionResponse_ReleaseList* AudioCollectionResponse::mutable_release_list() {
  set_has_release_list();
  if (release_list_ == NULL) release_list_ = new ::Remote::AudioCollectionResponse_ReleaseList;
  return release_list_;
}
inline ::Remote::AudioCollectionResponse_ReleaseList* AudioCollectionResponse::release_release_list() {
  clear_has_release_list();
  ::Remote::AudioCollectionResponse_ReleaseList* temp = release_list_;
  release_list_ = NULL;
  return temp;
}
inline void AudioCollectionResponse::set_allocated_release_list(::Remote::AudioCollectionResponse_ReleaseList* release_list) {
  delete release_list_;
  release_list_ = release_list;
  if (release_list) {
    set_has_release_list();
  } else {
    clear_has_release_list();
  }
}

// optional .Remote.AudioCollectionResponse.TrackList track_list = 6;
inline bool AudioCollectionResponse::has_track_list() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioCollectionResponse::set_has_track_list() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioCollectionResponse::clear_has_track_list() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioCollectionResponse::clear_track_list() {
  if (track_list_ != NULL) track_list_->::Remote::AudioCollectionResponse_TrackList::Clear();
  clear_has_track_list();
}
inline const ::Remote::AudioCollectionResponse_TrackList& AudioCollectionResponse::track_list() const {
  return track_list_ != NULL ? *track_list_ : *default_instance_->track_list_;
}
inline ::Remote::AudioCollectionResponse_TrackList* AudioCollectionResponse::mutable_track_list() {
  set_has_track_list();
  if (track_list_ == NULL) track_list_ = new ::Remote::AudioCollectionResponse_TrackList;
  return track_list_;
}
inline ::Remote::AudioCollectionResponse_TrackList* AudioCollectionResponse::release_track_list() {
  clear_has_track_list();
  ::Remote::AudioCollectionResponse_TrackList* temp = track_list_;
  track_list_ = NULL;
  return temp;
}
inline void AudioCollectionResponse::set_allocated_track_list(::Remote::AudioCollectionResponse_TrackList* track_list) {
  delete track_list_;
  track_list_ = track_list;
  if (track_list) {
    set_has_track_list();
  } else {
    clear_has_track_list();
  }
}

// repeated .Remote.AudioCollectionResponse.CoverArt cover_art = 7;
inline int AudioCollectionResponse::cover_art_size() const {
  return cover_art_.size();
}
inline void AudioCollectionResponse::clear_cover_art() {
  cover_art_.Clear();
}
inline const ::Remote::AudioCollectionResponse_CoverArt& AudioCollectionResponse::cover_art(int index) const {
  return cover_art_.Get(index);
}
inline ::Remote::AudioCollectionResponse_CoverArt* AudioCollectionResponse::mutable_cover_art(int index) {
  return cover_art_.Mutable(index);
}
inline ::Remote::AudioCollectionResponse_CoverArt* AudioCollectionResponse::add_cover_art() {
  return cover_art_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_CoverArt >&
AudioCollectionResponse::cover_art() const {
  return cover_art_;
}
inline ::google::protobuf::RepeatedPtrField< ::Remote::AudioCollectionResponse_CoverArt >*
AudioCollectionResponse::mutable_cover_art() {
  return &cover_art_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Remote

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Remote::AudioCollectionRequest_GetCoverArt_Type>() {
  return ::Remote::AudioCollectionRequest_GetCoverArt_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Remote::AudioCollectionRequest_Type>() {
  return ::Remote::AudioCollectionRequest_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Remote::AudioCollectionResponse_Type>() {
  return ::Remote::AudioCollectionResponse_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_collection_2eproto__INCLUDED
